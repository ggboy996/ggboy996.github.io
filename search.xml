<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线程间通信]]></title>
    <url>%2F2019%2F05%2F05%2F%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1.使用wait/notify实现线程间的通信1.1 等待/通知机制的实现方法wait()的作用是使当前执行代码的线程进行等待。在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步代码块中调用wait()方法。在执行wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。方法notify()也要在同步方法或同步代码块中调用。该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则按优先级来获取，否则随机挑选一个呈wait状态的线程，对其发出通知notify，并使它进入就绪队列，也叫锁池。另外需要说明的是，在执行notify()方法之后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程将程序执行完，也就是推出synchronized代码块后，当前线程才会释放锁，然后由就绪队列里的线程争夺锁。当一个获得了该对象的wait()线程运行完毕后，会释放该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。 1.2 方法wait(long)的使用带一个参数的的wait(long)方法的功能是等待某一时间内是否有线程对锁唤醒，如果超过这个时间则自动唤醒。 1.3 等待wait的条件发生变化如果采用if判断，当线程从wait中唤醒时，那么将直接执行处理其他业务逻辑的代码，但这时候可能出现另外一种可能，条件谓词已经不满足处理业务逻辑的条件了，从而出现错误的结果，于是有必要进行再一次判断，所有一般wait()方法是在while循环里，这样便于检测wait的条件是否变化。 2.生产者/消费者模式的实现2.1 线程假死现象“假死”现象其实就是线程全部进入WAITING等待状态，这时，程序不再执行任何业务功能，整个项目呈停止状态。“假死”出现的原因是notify唤醒的时候，也许是异类，也许是同类，比如生产者唤醒生产者，或消费者唤醒消费者这样的情况。如果按这样运行的比率积少成多，最终就会导致所有的线程都不能继续运行下去，大家都在等待，都呈WAITING状态，就是”假死”。 3.方法join的使用方法join()的作用是使所属的线程对象X正常执行run()方法中的任务，而使当前线程Z进行无限期的阻塞，等待线程X销毁后再继续执行线程Z后面的代码。 3.1 join与synchronized的区别方法join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait()方法进行等待，而sychroized该关键字使用的是”对象监视器”原理做为同步。 3.2 方法join(long)与sleep(long)的区别join(long)的功能在内部是使用wait(long)方法实现的，所以join(long)方法具有释放锁的特点。而Thread.sleep(long)方法却不释放锁。 4.ThreadLocal的使用类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子里可以存储每个线程的私有数据。 4.1 ThreadLocal的内部结构图 从上面的结构图，我们已经窥见ThreadLocal的核心机制： 每个Thread线程内部都有一个Map。Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 4.2 ThreadLocal与InheritableThreadLocal的区别ThreadLocal和InheritableThreadLocal本质上只是为了方便编码给的工具类，具体存数据是ThreadLocalMap 对象。ThreadLocalMap 存的key对象是ThreadLocal，value就是真正需要存的业务对象。Thread里通过两个变量持用ThreadLocalMap 对象，分别为：threadLocals和inheritableThreadLocals。InheritableThreadLocal之所以能够完成线程间变量的传递，是在new Thread()的时候对inheritableThreadLocals对像里的值进行了复制。子线程通过继承得到的InheritableThreadLocal里的值与父线程里的InheritableThreadLocal的值具有相同的引用，如果父子线程想实现不影响各自的对象，可以重写InheritableThreadLocal的childValue方法。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2F2019%2F05%2F03%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[关键字volatile的主要作用是使变量在多个线程间可见。具体来说就是，volatile关键字，可以强制的从公共内存中读取变量的值，这样就不会因为私有堆栈中的值和公共堆栈中的值不同步而导致错误。 1.volatile 和 synchronized 的比较1) volatile只能修饰于变量，而 synchronized可以修饰方法，以及代码块。2) 多线程访问 volatile不会发生阻塞，而 synchronized会出现阻塞。3) volatile能保证数据的可见性，但不能保证原子性。 synchronized两者都可以保证。4) volatile解决的是变量在多个线程之间的可见性，而 synchronized解决的是多个线程之间访问资源的同步性。 2. i++操作时的非线程安全问题表达式i++的操作步骤分解如下： 1)从内存中取出i的值2)计算i的值3)将i的值写到内存中 假如在第二步计算值的时候，另外一个线程也修改i的值，这时候就会出现脏数据。解决方法就是使用 synchronized关键字。 3.synchronized有和volatile一样的功能synchronized不仅可以保证同步，还可以保证可见性。在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>volatile关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized同步语句块]]></title>
    <url>%2F2019%2F05%2F02%2Fsynchronized%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97%2F</url>
    <content type="text"><![CDATA[用关键字 synchronized 来声明方法在某些情况下是有弊端的，比如A线程调用了同步方法执行一个长时间的任务，那么B线程则必须等待比较长的时间。在这种情况下可以使用 synchronized同步语句块 来解决。 synchronized方法 是对当前对象加锁，而 synchronized同步语句块 是对某一个对象加锁。 1.用同步代码块解决同步方法的弊端同步方法的弊端上面说过了，就是效率慢。为什么同步代码块就能解决？因为当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中的非 synchronized(this) 同步代码块。 2.synchronized代码块间的同步性当一个线程访问object的 synchronized(this)同步代码块时，其他线程对同一个object中所有其他 synchronized(this)同步代码块的访问将被阻塞，这说明 synchronized 使用的对象监视器是一个。但可以异步访问 synchronized(其他对象) 的语句块。因为这时候他们的对象监视器就不是同一个了。 3.synchronized锁定的是当前对象synchronized(this)代码块锁定的是当前对象，和 synchronized方法是一样的。这就意味着，他们的对象监视器是同一个，会发生排斥。也就是说，当A线程在访问object的 synchronized(this)同步代码块的时候，那么B线程这时候访问object中的 synchronized方法就会受阻，必须等A线程访问结束，释放了锁后,B线程才能访问。因为他们持有的是同一个锁，都是锁定的当前对象。同一个object里的 synchronized(anthing) 和 synchronized(this) 是不互斥的，可以异步执行。同一个object里的 synchronized(anthing) 和 synchronized方法 是不互斥的，可以异步执行。同一个object里的 synchronized方法 和 synchronized(this) 是互斥的，必须同步执行。 4.synchronized(非this对象x)的三个结论“synchronized(非this对象x)”格式的写法是将x对象本身作为”对象监视器” 1)当多个线程同时执行 synchronized(x){}同步代码块时呈同步效果。2)当其他线程执行x对象中 synchronized同步方法时呈同步效果。3)当其他线程执行x对象方法里面的 synchronized(this)代码块时也呈同步效果。注意：如果其他线程调用的是不加 synchronized 关键字的方法时，还是异步调用 5.静态同步 synchronized方法与 synchronized(class)代码块synchronized关键字还可以用在 static静态方法上，这样写的话，就是对当前.java文件对应的Class类持锁。和 synchronized关键字加到非static静态方法不一样，这个是给对象上锁。 1)当A线程执行object里的 synchronized修饰的 static静态方法时，那么其他线程不能同时执行该object里用 synchronized修饰的static静态方法。属于互斥状态。1)当A线程执行object里的 synchronized修饰的 static静态方法时，其他线程可以执行该object里用 synchronized修饰的非static静态方法。不属于互斥状态，因为不是同一把锁。3)同步synchronized(xx.class)作用和 synchronized static 方法的作用一样。 synchronized static 方法需是xx.class里的。 6.数据类型String的常量池特性在jvm中具有String常量池缓存的功能。简单来说，就是我输一次A，如果String常量池没有A，那么这个A就会被保存在String常量池里。当我要用A时，这时就会把String常量池里的A指向变量。所有的A都是同一个。如果把A当作锁，那么便会出现相同的锁，就会出现问题。 7.锁对象的改变如果锁对象的值中途改变，那么锁也就会改变，马上会由同步变为异步。需要注意的是：只要对象不变，即使对象的属性被改变，运行的结果还是同步。比如对象是USER这个类，运行过程中，改变了USER里的一个属性name的值，但对象还是没变，还是会同步执行下去。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized同步方法]]></title>
    <url>%2F2019%2F04%2F29%2Fsynchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[”非线程安全“会在多个线程对同一个对象中的实例对象进行并发访问时发生，产生的后果就是”脏读“，也就是取到的数据其实是被更改过的。而”线程安全“就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。 #1.方法内的变量为线程安全 方法中的变量不存在非线程安全问题，这是方法内部的变量是私有的特性造成的。 #2.实例变量非线程安全 如果多个线程共同访问1个对象中的实例变量，需要在方法前添加关键字 synchronized 。这样就不会出现非线程安全问题。 #3.多个对象多个锁 123456Hbbq h1 = new Hbbq();Hbbq h2 = new Hbbq();Thread athread = new Thread(h1);athread.start();Thread bthread = new Thread(h2);bthread.start(); 从以上代码可以看出，我们创建了两个 Hbbq 的实例对象。这样的话，加了 synchronized 的方法，便会产生两个锁，结果就不会是同步，而是以异步的方式运行的。如果多个线程访问多个对象，JVM就会创建多个锁，就像上面的示例一样。同步的单词是 synchronized ，异步的单词是 asynchronized。 #4.synchronized方法与锁对象 当两个线程同时访问一个对象的不同的两个方法：第一次实验的是一个同步的方法，一个不同步的方法第二次实验的是两个都是同步的方法 代码我就不贴了，直接写结论：1）A线程先持有object对象的lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。2）A线程先持有object对象的lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需等待，也就是同步。 #5.脏读 出现脏读的原因就是不同步。解决的方法就是加上同步synchronized关键字。这里注意一点，当一个线程A调用了对象里加入synchronized关键字的X方法时，那么A线程就获得了X的方法锁，更准确的讲，是获得了这个对象的锁，其他线程必须等待A线程执行完毕才可以调用X方法，但其他线程可以随意调用其他的非synchronized同步方法。所以，需要把set 和 get 方法都加上 synchronized 关键字，这样的话就可以避免出现脏读。 #6.synchronized锁重入 可重入锁的概念是：自己可以再次获取自己的内部锁。这样就可以调用 synchronized方法 里的 synchronized方法。可重入锁也支持在父子类继承的环境中。在子类中调用父类里的变量，值也可以同步。 #7.出现异常，锁自动释放 就是说，当一个线程执行的代码出现异常时，那么这个线程所持有的锁会被自动释放，然后别的线程就可以继续去调用这个方法了。 #8.同步不具有继承性 当一个子类继承一个父类时，子类重写父类的 synchronized 方法，却没有加关键字 synchronized，这样就会造成非线程安全(异步)。由此可以看出，同步不能继承。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[有三种方式来停止线程：1. 正常执行 run()方法，run()方法结束后，线程终止。2. 使用 stop 方法强行终止线程，不推荐使用，会造成不可预料的后果。3. 使用 interrupt 方法中断线程。 现在对于第三种方式来详细了解一下。在Java的SDK中，Thread.java类提供了两种方法：1) this.interrupted()：测试当前线程是否已经中断。2) this.isinterrupted()：测试线程是否已经中断。interrupted()是静态方法，所以我们用Thread.interrupted()方法表示，它调用的是currentThread().isInterrupted(true)方法，即说明是返回当前线程的是否已经中断的状态值，而且有清理中断状态的机制。而isInterrupted()是一个实例方法，所以我们用this.isInterrupted()方法表示，它调用的是isInterrupted(false)方法，意思是返回线程是否已经中断的状态值，与Thread.interrupted()方法相反，它没有清理中断状态的机制。 二者的区别在于：interrupted()是static方法，调用的时候要用Thread.interrupted()，而isInterrupted()是实例方法，调用时要用线程的实例调用；Thread.interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能；this.isInterrupted()：测试线程Thread对象是否已经是中断状态，但不清除状态标志。 线程的停止——抛异常法1234567891011121314151617181920public class MyThread4 extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 50000; i++) &#123; if (this.isInterrupted()) &#123; System.out.println( &quot;线程已经结束，我要退出&quot; );// return; //这是return法停止线程 throw new InterruptedException(); //抛异常法停止线程 &#125; System.out.println( &quot;i=&quot; + (i + 1) ); &#125; System.out.println( &quot;我是for下面的语句，我被执行说明线程没有真正结束&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;进入MyThread.java类中run方法的catch异常了&quot; ); e.printStackTrace(); &#125; &#125;&#125; 1234567891011public static void main(String[] args) &#123; try &#123; MyThread4 myThread4 = new MyThread4(); myThread4.start(); Thread.sleep( 20); myThread4.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 推荐使用抛异常法。 线程的停止——在沉睡中停止这个名字非常好听，让我们看下具体是怎么实现的。12345678910111213141516171819202122public void run() &#123; super.run(); try &#123; System.out.println( &quot;begin run&quot; ); Thread.sleep( 500 ); System.out.println( &quot;begin end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;在沉睡中终止&quot;); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); Thread.sleep( 20 ); thread5.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 其实就是在执行中断操作前，执行一个sleep()方法。那为什么这样就能停止线程呢？看这句话：当线程处于下面的状况时（（1）如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个InterruptedException异常。这个时候，我们可以通过捕获InterruptedException异常来终止线程的执行，具体可以通过return等退出或改变共享变量的值使其退出。）这样看来，其实这两个方法都属于抛异常法，一个是主动抛出异常，一个是调用sleep()后，被系统抛出异常。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识多线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[开始系统地来学习多线程。采用边学变记录的方式。不想耽误太多时间来码字，所以我打算写的随意一点，以自己能看懂为目的，来记录一些需要记住的知识，便于日后的复习，虽然也可能根本不复习，但是记录还是有用的，至少能让后我现在加深一次记忆。 1. 进程，线程1.1 进程运行在内存中的exe程序，就是进程。就像任务管理器里看到的exe程序，都是正在运行的进程。 1.2 线程线程可以理解为，在进程中独立运行的子任务。打个比方，QQ.exe运行时就有很多子任务在同时运行，比如好友视频线程，下载文件线程，发送表情线程等等。这些不同的任务都能同时进行，这些子任务都可以理解为线程在工作。 1.3 线程的优点使用多线程，可以在同一时间同时运行不同种类的任务。通过一个图可以清楚的看到优点所在。使用多线程，任务2便不用等到任务1运行完才能运行。这是就是多线程的优点，使用多线程也就是在使用异步。 2. 使用多线程有两种方法来实现多线程，一种是继承Thread类，一种是实现Runnable接口。因为Java不支持多继承，一个子类只能有一个父类。所以当想创建的线程类已经有一个父类时，就不能再继承Thread类了，这时需要通过实现Runnable类来实现多线程。注意：启动多线程，必须使用thread.start()方法，且类里的方法名必须为run()，开启start()方法后，run()方法会被自动调用。另外还需要知道，执行start()方法的顺序不代表线程启动的顺序，顺序是随机的。 2.1 非线程安全问题指的是多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。解决方法是在方法前加 synchronized 关键字。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识IO]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%A4%E8%AF%86IO%2F</url>
    <content type="text"><![CDATA[大多数应用程序都需要实现与设备之间的数据传输。在Java中，将通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象描述为”流”。Java中的流都位于 java.io 包中，称为IO(输入输出)流。 1.字节流1.1 字节流的概念在计算机中，无论是文本、图片、音频还是视频，所有的文件都是以二进制(字节)形式存在的。IO流中针对字节的输入输出提供了一系列的流，统称为字节流。在JDK中，提供了两个抽象类 InputStream 和 OutputStream ,他们是字节流的顶级父类，所有的字节输入流都继承自 InputStream ，所有的字节输出流都继承自 OutputStream 。 1.2 字节流读写文件针对文件的独写，JDK专门提供了两个类，分别是 FileInputStream 和 FileOutputStream 。FileInputStream 是 InputStream 的子类，它是操作文件的字节输入流，专门用于读取文件中的数据。FileOutputStream 是 OutputStream 的子类，它是操作文件的字节输出流，专门用于把数据写入文件。 1.3 字节流的缓冲区主要代码：12345byte[] buff = new byte[1024];int len;while((len=in.read(buff))!=-1)&#123;out.write(buff,0,len)&#125; 上述代码实现了用缓冲区来拷贝文件。首先定义了一个字节数组，作为缓冲区。字节数组被填满后，执行写入，把字节数组里的内容全部写入。最后输出流关闭时，也会执行写入，可以防止数组里没有写满的没有写入文件。 1.4 字节缓冲流在IO包中提供两个带缓冲的字节流，分别是 BufferedInputStream 和 BufferedOutputStream 。简单理解就是，自带了缓冲区的字节流。使用方法，把类包装起来。主要代码如下：BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;src.txt&quot;));就这样包起来，所以也叫包装流。 2.字符流InputStream 类和 OutputStream 类在读写文件时操作的都是字节。同样，JDK也提供了字符流，用来操作字符。Reader 和 Writer 分别是两个抽象的顶级父类。Reader是字符输入流，用与读取字符。Writer是字符输出流，用于写入字符。 2.1 字符流操作文件FileReader 是 Reader 的子类，可以读取一个或一组字符。FileWriter 是 Writer 的子类，用于写入字符。同字节缓冲流一样，字符也有字符缓冲流 BufferedReader 和 BufferedWriter 。操作方法也一样。需要注意的是，BufferedWriter 中的一个重要方法 readLine()，和 FileOutputStream 里的 read()，用法一样，区别是read()一次读取一个字节，而readLine()一次读取一行字符。需要注意。 2.2 转换流字节流和字符流之间可以互相转换。利用 InputStreamReader 和 OutputStreamWriter 这两个类进行转换。转换流其实也是一种包装流，其中 OutputStreamWriter 是 Writer 的子类,InputStreamReader 是 Reader 的子类。用的时候包装一下就可以了，和上面两个缓冲流用法一样。 3.其他流3.1 ObjectInputStream 和 ObjectOutputStream程序运行时，会创建对象，程序结束后，这些对象会被垃圾回收。如果希望永久保存这些对象，则可以将对象转为字节数据写入硬盘，这个过程叫对象序列化。JDK提供了 ObjectOutputStream 来实现序列化, ObjectInputStream 用来反序列化。当对象序列化时，必须保证对象实现了Serializable接口，否则程序会报错。]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件装载流程]]></title>
    <url>%2F2019%2F04%2F15%2Fclass%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.装载流程图class文件的装载流程如图所示。 2.类装载的条件首先我们要搞清楚，class只有在必须要使用时才会被装载。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：· 当创建一个类的实例时，比如使用new关键字，或者通过反射，克隆，反序列化· 当调用类的静态方法，即当使用了字节码 invokestatic 指令· 当使用类或接口的静态字段时（final常量除外），比如，使用 getstatic 或者 putstatic 指令· 当使用 java.lang.refect 包中的方法反射类的方法时· 当初始化子类时，要求先初始化父类· 作为启动虚拟机，含有main()方法的那个类 3.流程分析3.1 加载类加载类处于类装载的第一个阶段。在加载类时，java虚拟机必须完成以下工作:· 通过类的全名，获取类的二进制数据流· 解析类的二进制数据流为方法区内的数据结构· 创建java.lang.Class 类的实例，表示该类型 对于类的二进制流数据，虚拟机可以通过多种途径产生和获得。最一般地是通过文件系统读入一个class文件。在获取类的二进制信息后，Java虚拟机就会处理这些数据，并最终转化为一个java.lang.Class的实例，java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据。通过class类提供的接口，可以访问一个类的方法，字段等信息。 3.2 连接连接可以分为三个步骤：验证，准备，解析。 3.2.1 验证类当类加载到系统后，就开始连接操作，验证是连接操作的第一步。大体上Java虚拟机需要做以下的检查：检查的内容如图所示，比较详细，我就不一一说明了。 3.2.2 准备当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置初始值。如果类中存在常量字段，那么常量字段也会在准备阶段被附上正确的值，这个赋值属于Java虚拟机的行为，属于变量的初始化。在这个阶段，不会有任何Java代码被执行。 3.2.3 解析类在准备阶段完成后，就进入到了解析阶段。解析阶段的工作就是将类、接口、字段和方法的符号引用转为直接引用。Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。这就是解析阶段的工作，将类、接口、字段和方法的符号引用转为直接引用。 3.3 初始化类的初始化是类装载的最后一个阶段。此时，类才会开始执行Java字节码。主要工作是执行类的初始化方法 。方法是由编译器自动生成的，它是由类静态成员的赋值语句以及 static 语句结合产生的。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>class文件装载流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笑忘录]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%AC%91%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[人与政权的斗争，就是记忆与遗忘的斗争。 —米兰昆德拉 今天下午看到了一些东西。这些东西颠覆了我的认知。让我感到无奈，无力，压抑。 我很难受，但是却没法和人说。我深知互联网不是可以畅所欲言的地方。 在这一点上，他们是成功的。身边也无人可说，因为很多人都不知道，至少我身边的人应该是不知道。在这一点上，他们也是成功的。 但这样是不对的，不应该以这样的方式来对待。我们不应该忘记，我们也不能忘记，我们需要一个说法。 我避免了很多的敏感词汇，这样的叙述让我很难受，丝毫表达不出我所想。但我又很怂，我不知道写在这里有没有事。在一点上，我更加敬佩那些能够勇于发声的人。这样的人，最终都不会有什么好的结果。但这样的人，才是真正伟大的人。 写出来这些话，我认为这样能让我舒服一点，但是好像没什么用。了解了更多，只会觉得我们更加可悲。似乎理解了一些人，也感觉自己之前的思想很可笑，无知。 我希望她能够等到那一天的到来，如果不行，我希望我可以等到那一天的到来。如果还不行，至少希望自己到时不要已经变成一个麻木不堪，对什么都不在意的人。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo插入图片]]></title>
    <url>%2F2019%2F04%2F14%2Fpictest%2F</url>
    <content type="text"><![CDATA[1.更改 _config.yml 配置文件首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.安装插件到博客的根目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save命令来进行插件的安装，用于加载本地文件。 3.创建文章执行 hexo new page pictest 创建文章。执行后我们会发现，这次创建 pictest.md 文章的同时，还会多出来一个 pictest 的文件夹。我们可以把文章里所用到的静态资源都放在这里，然后在文章里进行引用。 4.引用方式![图片别名随便写](pictest/图片名称.jpg) 5.引用我们来引用一张图片试一下 6.部署三连hexo cleanhexo ghexo d 7.打开浏览器查看是否成功]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法初试]]></title>
    <url>%2F2019%2F04%2F12%2FMarkdown%E8%AF%AD%E6%B3%95%E5%88%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.标题测试1.1不错 1.2还可以吧 1.3应该行 2.链接测试2.1 普通链接这是我的微博这是我的简书代码：[这是我的微博](https://weibo.com/u/6059487421?is_hot=1/)[这是我的简书](https://www.jianshu.com/u/21a1a8bdb771/) 2.2 自动链接这是我的微博：https://weibo.com/u/6059487421?is_hot=1这是我的简书：https://www.jianshu.com/u/21a1a8bdb771 3.代码测试3.1 行内代码system.out.println(&quot;你好！&quot;) 3.2 多行代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.hfbin.sync003;/** * 对象锁的同步和异步问题 * @author cn.hfbin * */public class MyObject &#123; public synchronized void method1()&#123; try &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** synchronized */ public void method2()&#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject mo = new MyObject(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method1(); &#125; &#125;,&quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method2(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; 4.引用测试 我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。表示尽管自己惯于冷眼看待军阀政府的文过饰非，从最坏最恶毒的方面去推测他们可能的做法，仍然料不到他们竟然凶残到超出自己的想象。 ​]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号大记]]></title>
    <url>%2F2019%2F04%2F10%2FsecondBlog%2F</url>
    <content type="text"><![CDATA[待会有课夜里也有课今天跑不成步了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号小记]]></title>
    <url>%2F2019%2F04%2F10%2Fnewpapername%2F</url>
    <content type="text"><![CDATA[今天有点冷，还可以吧。运动会，可以买水了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
</search>
