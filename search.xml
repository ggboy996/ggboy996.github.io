<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[synchronized同步方法]]></title>
    <url>%2F2019%2F04%2F29%2Fsynchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[”非线程安全“会在多个线程对同一个对象中的实例对象进行并发访问时发生，产生的后果就是”脏读“，也就是取到的数据其实是被更改过的。而”线程安全“就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。 #1.方法内的变量为线程安全 方法中的变量不存在非线程安全问题，这是方法内部的变量是私有的特性造成的。 #2.实例变量非线程安全 如果多个线程共同访问1个对象中的实例变量，需要在方法前添加关键字 synchronized 。这样就不会出现非线程安全问题。 #3.多个对象多个锁 123456Hbbq h1 = new Hbbq();Hbbq h2 = new Hbbq();Thread athread = new Thread(h1);athread.start();Thread bthread = new Thread(h2);bthread.start(); 从以上代码可以看出，我们创建了两个 Hbbq 的实例对象。这样的话，加了 synchronized 的方法，便会产生两个锁，结果就不会是同步，而是以异步的方式运行的。如果多个线程访问多个对象，JVM就会创建多个锁，就像上面的示例一样。同步的单词是 synchronized ，异步的单词是 asynchronized。 #4.synchronized方法与锁对象 当两个线程同时访问一个对象的不同的两个方法：第一次实验的是一个同步的方法，一个不同步的方法第二次实验的是两个都是同步的方法 代码我就不贴了，直接写结论：1）A线程先持有object对象的lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。2）A线程先持有object对象的lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需等待，也就是同步。 #5.脏读 出现脏读的原因就是不同步。解决的方法就是加上同步synchronized关键字。这里注意一点，当一个线程A调用了对象里加入synchronized关键字的X方法时，那么A线程就获得了X的方法锁，更准确的讲，是获得了这个对象的锁，其他线程必须等待A线程执行完毕才可以调用X方法，但其他线程可以随意调用其他的非synchronized同步方法。所以，需要把set 和 get 方法都加上 synchronized 关键字，这样的话就可以避免出现脏读。 #6.synchronized锁重入 可重入锁的概念是：自己可以再次获取自己的内部锁。这样就可以调用 synchronized方法 里的 synchronized方法。可重入锁也支持在父子类继承的环境中。在子类中调用父类里的变量，值也可以同步。 #7.出现异常，锁自动释放 就是说，当一个线程执行的代码出现异常时，那么这个线程所持有的锁会被自动释放，然后别的线程就可以继续去调用这个方法了。 #8.同步不具有继承性 当一个子类继承一个父类时，子类重写父类的 synchronized 方法，却没有加关键字 synchronized，这样就会造成非线程安全(异步)。由此可以看出，同步不能继承。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[有三种方式来停止线程：1. 正常执行 run()方法，run()方法结束后，线程终止。2. 使用 stop 方法强行终止线程，不推荐使用，会造成不可预料的后果。3. 使用 interrupt 方法中断线程。 现在对于第三种方式来详细了解一下。在Java的SDK中，Thread.java类提供了两种方法：1) this.interrupted()：测试当前线程是否已经中断。2) this.isinterrupted()：测试线程是否已经中断。interrupted()是静态方法，所以我们用Thread.interrupted()方法表示，它调用的是currentThread().isInterrupted(true)方法，即说明是返回当前线程的是否已经中断的状态值，而且有清理中断状态的机制。而isInterrupted()是一个实例方法，所以我们用this.isInterrupted()方法表示，它调用的是isInterrupted(false)方法，意思是返回线程是否已经中断的状态值，与Thread.interrupted()方法相反，它没有清理中断状态的机制。 二者的区别在于：interrupted()是static方法，调用的时候要用Thread.interrupted()，而isInterrupted()是实例方法，调用时要用线程的实例调用；Thread.interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能；this.isInterrupted()：测试线程Thread对象是否已经是中断状态，但不清除状态标志。 线程的停止——抛异常法1234567891011121314151617181920public class MyThread4 extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 50000; i++) &#123; if (this.isInterrupted()) &#123; System.out.println( &quot;线程已经结束，我要退出&quot; );// return; //这是return法停止线程 throw new InterruptedException(); //抛异常法停止线程 &#125; System.out.println( &quot;i=&quot; + (i + 1) ); &#125; System.out.println( &quot;我是for下面的语句，我被执行说明线程没有真正结束&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;进入MyThread.java类中run方法的catch异常了&quot; ); e.printStackTrace(); &#125; &#125;&#125; 1234567891011public static void main(String[] args) &#123; try &#123; MyThread4 myThread4 = new MyThread4(); myThread4.start(); Thread.sleep( 20); myThread4.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 推荐使用抛异常法。 线程的停止——在沉睡中停止这个名字非常好听，让我们看下具体是怎么实现的。12345678910111213141516171819202122public void run() &#123; super.run(); try &#123; System.out.println( &quot;begin run&quot; ); Thread.sleep( 500 ); System.out.println( &quot;begin end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;在沉睡中终止&quot;); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); Thread.sleep( 20 ); thread5.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 其实就是在执行中断操作前，执行一个sleep()方法。那为什么这样就能停止线程呢？看这句话：当线程处于下面的状况时（（1）如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个InterruptedException异常。这个时候，我们可以通过捕获InterruptedException异常来终止线程的执行，具体可以通过return等退出或改变共享变量的值使其退出。）这样看来，其实这两个方法都属于抛异常法，一个是主动抛出异常，一个是调用sleep()后，被系统抛出异常。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识多线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[开始系统地来学习多线程。采用边学变记录的方式。不想耽误太多时间来码字，所以我打算写的随意一点，以自己能看懂为目的，来记录一些需要记住的知识，便于日后的复习，虽然也可能根本不复习，但是记录还是有用的，至少能让后我现在加深一次记忆。 1. 进程，线程1.1 进程运行在内存中的exe程序，就是进程。就像任务管理器里看到的exe程序，都是正在运行的进程。 1.2 线程线程可以理解为，在进程中独立运行的子任务。打个比方，QQ.exe运行时就有很多子任务在同时运行，比如好友视频线程，下载文件线程，发送表情线程等等。这些不同的任务都能同时进行，这些子任务都可以理解为线程在工作。 1.3 线程的优点使用多线程，可以在同一时间同时运行不同种类的任务。通过一个图可以清楚的看到优点所在。使用多线程，任务2便不用等到任务1运行完才能运行。这是就是多线程的优点，使用多线程也就是在使用异步。 2. 使用多线程有两种方法来实现多线程，一种是继承Thread类，一种是实现Runnable接口。因为Java不支持多继承，一个子类只能有一个父类。所以当想创建的线程类已经有一个父类时，就不能再继承Thread类了，这时需要通过实现Runnable类来实现多线程。注意：启动多线程，必须使用thread.start()方法，且类里的方法名必须为run()，开启start()方法后，run()方法会被自动调用。另外还需要知道，执行start()方法的顺序不代表线程启动的顺序，顺序是随机的。 2.1 非线程安全问题指的是多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。解决方法是在方法前加 synchronized 关键字。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识IO]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%A4%E8%AF%86IO%2F</url>
    <content type="text"><![CDATA[大多数应用程序都需要实现与设备之间的数据传输。在Java中，将通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象描述为”流”。Java中的流都位于 java.io 包中，称为IO(输入输出)流。 1.字节流1.1 字节流的概念在计算机中，无论是文本、图片、音频还是视频，所有的文件都是以二进制(字节)形式存在的。IO流中针对字节的输入输出提供了一系列的流，统称为字节流。在JDK中，提供了两个抽象类 InputStream 和 OutputStream ,他们是字节流的顶级父类，所有的字节输入流都继承自 InputStream ，所有的字节输出流都继承自 OutputStream 。 1.2 字节流读写文件针对文件的独写，JDK专门提供了两个类，分别是 FileInputStream 和 FileOutputStream 。FileInputStream 是 InputStream 的子类，它是操作文件的字节输入流，专门用于读取文件中的数据。FileOutputStream 是 OutputStream 的子类，它是操作文件的字节输出流，专门用于把数据写入文件。 1.3 字节流的缓冲区主要代码：12345byte[] buff = new byte[1024];int len;while((len=in.read(buff))!=-1)&#123;out.write(buff,0,len)&#125; 上述代码实现了用缓冲区来拷贝文件。首先定义了一个字节数组，作为缓冲区。字节数组被填满后，执行写入，把字节数组里的内容全部写入。最后输出流关闭时，也会执行写入，可以防止数组里没有写满的没有写入文件。 1.4 字节缓冲流在IO包中提供两个带缓冲的字节流，分别是 BufferedInputStream 和 BufferedOutputStream 。简单理解就是，自带了缓冲区的字节流。使用方法，把类包装起来。主要代码如下：BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;src.txt&quot;));就这样包起来，所以也叫包装流。 2.字符流InputStream 类和 OutputStream 类在读写文件时操作的都是字节。同样，JDK也提供了字符流，用来操作字符。Reader 和 Writer 分别是两个抽象的顶级父类。Reader是字符输入流，用与读取字符。Writer是字符输出流，用于写入字符。 2.1 字符流操作文件FileReader 是 Reader 的子类，可以读取一个或一组字符。FileWriter 是 Writer 的子类，用于写入字符。同字节缓冲流一样，字符也有字符缓冲流 BufferedReader 和 BufferedWriter 。操作方法也一样。需要注意的是，BufferedWriter 中的一个重要方法 readLine()，和 FileOutputStream 里的 read()，用法一样，区别是read()一次读取一个字节，而readLine()一次读取一行字符。需要注意。 2.2 转换流字节流和字符流之间可以互相转换。利用 InputStreamReader 和 OutputStreamWriter 这两个类进行转换。转换流其实也是一种包装流，其中 OutputStreamWriter 是 Writer 的子类,InputStreamReader 是 Reader 的子类。用的时候包装一下就可以了，和上面两个缓冲流用法一样。 3.其他流3.1 ObjectInputStream 和 ObjectOutputStream程序运行时，会创建对象，程序结束后，这些对象会被垃圾回收。如果希望永久保存这些对象，则可以将对象转为字节数据写入硬盘，这个过程叫对象序列化。JDK提供了 ObjectOutputStream 来实现序列化, ObjectInputStream 用来反序列化。当对象序列化时，必须保证对象实现了Serializable接口，否则程序会报错。]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件装载流程]]></title>
    <url>%2F2019%2F04%2F15%2Fclass%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.装载流程图class文件的装载流程如图所示。 2.类装载的条件首先我们要搞清楚，class只有在必须要使用时才会被装载。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：· 当创建一个类的实例时，比如使用new关键字，或者通过反射，克隆，反序列化· 当调用类的静态方法，即当使用了字节码 invokestatic 指令· 当使用类或接口的静态字段时（final常量除外），比如，使用 getstatic 或者 putstatic 指令· 当使用 java.lang.refect 包中的方法反射类的方法时· 当初始化子类时，要求先初始化父类· 作为启动虚拟机，含有main()方法的那个类 3.流程分析3.1 加载类加载类处于类装载的第一个阶段。在加载类时，java虚拟机必须完成以下工作:· 通过类的全名，获取类的二进制数据流· 解析类的二进制数据流为方法区内的数据结构· 创建java.lang.Class 类的实例，表示该类型 对于类的二进制流数据，虚拟机可以通过多种途径产生和获得。最一般地是通过文件系统读入一个class文件。在获取类的二进制信息后，Java虚拟机就会处理这些数据，并最终转化为一个java.lang.Class的实例，java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据。通过class类提供的接口，可以访问一个类的方法，字段等信息。 3.2 连接连接可以分为三个步骤：验证，准备，解析。 3.2.1 验证类当类加载到系统后，就开始连接操作，验证是连接操作的第一步。大体上Java虚拟机需要做以下的检查：检查的内容如图所示，比较详细，我就不一一说明了。 3.2.2 准备当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置初始值。如果类中存在常量字段，那么常量字段也会在准备阶段被附上正确的值，这个赋值属于Java虚拟机的行为，属于变量的初始化。在这个阶段，不会有任何Java代码被执行。 3.2.3 解析类在准备阶段完成后，就进入到了解析阶段。解析阶段的工作就是将类、接口、字段和方法的符号引用转为直接引用。Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。这就是解析阶段的工作，将类、接口、字段和方法的符号引用转为直接引用。 3.3 初始化类的初始化是类装载的最后一个阶段。此时，类才会开始执行Java字节码。主要工作是执行类的初始化方法 。方法是由编译器自动生成的，它是由类静态成员的赋值语句以及 static 语句结合产生的。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>class文件装载流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笑忘录]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%AC%91%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[人与政权的斗争，就是记忆与遗忘的斗争。 —米兰昆德拉 今天下午看到了一些东西。这些东西颠覆了我的认知。让我感到无奈，无力，压抑。 我很难受，但是却没法和人说。我深知互联网不是可以畅所欲言的地方。 在这一点上，他们是成功的。身边也无人可说，因为很多人都不知道，至少我身边的人应该是不知道。在这一点上，他们也是成功的。 但这样是不对的，不应该以这样的方式来对待。我们不应该忘记，我们也不能忘记，我们需要一个说法。 我避免了很多的敏感词汇，这样的叙述让我很难受，丝毫表达不出我所想。但我又很怂，我不知道写在这里有没有事。在一点上，我更加敬佩那些能够勇于发声的人。这样的人，最终都不会有什么好的结果。但这样的人，才是真正伟大的人。 写出来这些话，我认为这样能让我舒服一点，但是好像没什么用。了解了更多，只会觉得我们更加可悲。似乎理解了一些人，也感觉自己之前的思想很可笑，无知。 我希望她能够等到那一天的到来，如果不行，我希望我可以等到那一天的到来。如果还不行，至少希望自己到时不要已经变成一个麻木不堪，对什么都不在意的人。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo插入图片]]></title>
    <url>%2F2019%2F04%2F14%2Fpictest%2F</url>
    <content type="text"><![CDATA[1.更改 _config.yml 配置文件首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.安装插件到博客的根目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save命令来进行插件的安装，用于加载本地文件。 3.创建文章执行 hexo new page pictest 创建文章。执行后我们会发现，这次创建 pictest.md 文章的同时，还会多出来一个 pictest 的文件夹。我们可以把文章里所用到的静态资源都放在这里，然后在文章里进行引用。 4.引用方式![图片别名随便写](pictest/图片名称.jpg) 5.引用我们来引用一张图片试一下 6.部署三连hexo cleanhexo ghexo d 7.打开浏览器查看是否成功]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法初试]]></title>
    <url>%2F2019%2F04%2F12%2FMarkdown%E8%AF%AD%E6%B3%95%E5%88%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.标题测试1.1不错 1.2还可以吧 1.3应该行 2.链接测试2.1 普通链接这是我的微博这是我的简书代码：[这是我的微博](https://weibo.com/u/6059487421?is_hot=1/)[这是我的简书](https://www.jianshu.com/u/21a1a8bdb771/) 2.2 自动链接这是我的微博：https://weibo.com/u/6059487421?is_hot=1这是我的简书：https://www.jianshu.com/u/21a1a8bdb771 3.代码测试3.1 行内代码system.out.println(&quot;你好！&quot;) 3.2 多行代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.hfbin.sync003;/** * 对象锁的同步和异步问题 * @author cn.hfbin * */public class MyObject &#123; public synchronized void method1()&#123; try &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** synchronized */ public void method2()&#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject mo = new MyObject(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method1(); &#125; &#125;,&quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method2(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; 4.引用测试 我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。表示尽管自己惯于冷眼看待军阀政府的文过饰非，从最坏最恶毒的方面去推测他们可能的做法，仍然料不到他们竟然凶残到超出自己的想象。 ​]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号大记]]></title>
    <url>%2F2019%2F04%2F10%2FsecondBlog%2F</url>
    <content type="text"><![CDATA[待会有课夜里也有课今天跑不成步了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号小记]]></title>
    <url>%2F2019%2F04%2F10%2Fnewpapername%2F</url>
    <content type="text"><![CDATA[今天有点冷，还可以吧。运动会，可以买水了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
</search>
