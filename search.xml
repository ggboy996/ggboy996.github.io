<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hibernate和MyBatis]]></title>
    <url>%2F2019%2F06%2F02%2FHibernate%E5%92%8CMyBatis%2F</url>
    <content type="text"><![CDATA[一、开发速度的对比MyBatis框架相对简单很容易上手，但也相对简陋些。 比起两者的开发速度，不仅仅要考虑到两者的特性及性能，更要根据项目需求去考虑究竟哪一个更适合项目开发，比如：一个项目中用到的复杂查询基本没有，就是简单的增删改查，这样选择hibernate效率就很快了，因为基本的sql语句已经被封装好了，根本不需要你去写sql语句，这就节省了大量的时间，但是对于一个大型项目，复杂语句较多，这样再去选择hibernate就不是一个太好的选择，选择mybatis就会加快许多，而且语句的管理也比较方便。 二、开发工作量的对比Hibernate和MyBatis都有相应的代码生成工具。可以生成简单基本的DAO层方法。针对高级查询，Mybatis需要手动编写SQL语句，以及ResultMap。而Hibernate有良好的映射机制，开发者无需关心SQL的生成与结果映射，可以更专注于业务流程 三、sql优化方面Hibernate的查询会将表中的所有字段查询出来，这一点会有性能消耗。Hibernate也可以自己写SQL来指定需要查询的字段，但这样就破坏了Hibernate开发的简洁性。而Mybatis的SQL是手动编写的，所以可以按需求指定查询的字段。 四、对象管理的对比Hibernate 是完整的对象/关系映射解决方案，它提供了对象状态管理（state management）的功能，使开发者不再需要理会底层数据库系统的细节。也就是说，相对于常见的 JDBC/SQL 持久层方案中需要管理 SQL 语句，Hibernate采用了更自然的面向对象的视角来持久化 Java 应用中的数据。MyBatis需要自己去写 SQL 语句。 五、缓存机制Hibernate缓存Hibernate一级缓存是Session缓存，利用好一级缓存就需要对Session的生命周期进行管理好。建议在一个Action操作中使用一个Session。一级缓存需要对Session进行严格管理。 Hibernate二级缓存是SessionFactory级的缓存。 SessionFactory的缓存分为内置缓存和外置缓存。内置缓存中存放的是SessionFactory对象的一些集合属性包含的数据(映射元素据及预定SQL语句等),对于应用程序来说,它是只读的。外置缓存中存放的是数据库数据的副本,其作用和一级缓存类似.二级缓存除了以内存作为存储介质外,还可以选用硬盘等外部存储设备。二级缓存称为进程级缓存或SessionFactory级缓存，它可以被所有session共享，它的生命周期伴随着SessionFactory的生命周期存在和消亡。 MyBatis缓存Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。 SqlSessionFactory层面上的二级缓存默认是不开启的，二级缓存的开席需要进行配置，实现二级缓存的时候，MyBatis要求返回的POJO必须是可序列化的。 也就是要求实现Serializable接口，配置方法很简单，只需要在映射XML文件配置就可以开启缓存了。 六、总结相同点Hibernate与MyBatis都可以是通过SessionFactoryBuider由XML配置文件生成SessionFactory，然后由SessionFactory 生成Session，最后由Session来开启执行事务和SQL语句。其中SessionFactoryBuider，SessionFactory，Session的生命周期都是差不多的。 Mybatis优势MyBatis可以进行更为细致的SQL优化，可以减少查询字段。MyBatis容易掌握，而Hibernate门槛较高。 Hibernate优势Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。 他人总结Hibernate功能强大，数据库无关性好，O/R映射能力强，如果你对Hibernate相当精通，而且对Hibernate进行了适当的封装，那么你的项目整个持久层代码会相当简单，需要写的代码很少，开发速度很快，非常爽。Hibernate的缺点就是学习门槛不低，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要你的经验和能力都很强才行。iBATIS入门简单，即学即用，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。iBATIS的缺点就是框架还是比较简陋，功能尚有缺失，虽然简化了数据绑定代码，但是整个底层数据库查询实际还是要自己写的，工作量也比较大，而且不太容易适应快速数据库修改。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GC详解]]></title>
    <url>%2F2019%2F06%2F02%2FGC%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目前我们的主流JVM用的是HotSpot,HotSpot虚拟机的垃圾回收机制采用的是分代收集算法，识别垃圾用的是可达性分析算法。 一、什么时候进行垃圾回收？(1) 程序主动调用 System.gc() 时候 (2) 系统自身绝对GC触发的时机。触发的依据：根据Eden区和From Space区的内存大小来决定。当内存大小不足时，则会启动GC线程并停止应用线程。 二、对谁进行垃圾回收？也就是说，我们进行垃圾回收，回收的是哪些对象。JVM采用了可达性分析算法，进行搜索，对于搜索不到的对象进行标记。 可达性分析算法：通过“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。 GC Root对象包含： 1) 虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象) 虚拟机栈中的引用的对象，我们在程序中正常创建一个对象，对象会在堆上开辟一块空间，同时会将这块空间的地址作为引用保存到虚拟机栈中，如果对象生命周期结束了，那么引用就会从虚拟机栈中出栈，因此如果在虚拟机栈中有引用，就说明这个对象还是有用的，这种情况是最常见的。 2) 方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象) 我们在类中定义了全局的静态的对象，也就是使用了static关键字，由于虚拟机栈是线程私有的，所以这种对象的引用会保存在共有的方法区中，显然将方法区中的静态引用作为GC Roots是必须的。 3) 方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象) 常量引用，就是使用了static final关键字，由于这种引用初始化之后不会修改，所以方法区常量池里的引用的对象也应该作为GC Roots。最后一种是在使用JNI技术时，有时候单纯的Java代码并不能满足我们的需求，我们可能需要在Java中调用C或C++的代码，因此会使用native方法，JVM内存中专门有一块本地方法栈，用来保存这些对象的引用，所以本地方法栈中引用的对象也会被作为GC Roots。 4) 本地方法栈中(Native方法)引用的对象(可以理解为:引用Native方法的所有对象) 三、做了什么？做了什么？顾名思义，当然是把垃圾回收了。其实不止是释放了对象，对于搜索不到的对象，调用finalize()方法进行释放，对于可以搜索到的对象进行复制操作。 具体过程：当GC线程启动时，会通过可达性分析法把Eden区和From Space区的存活对象复制到To Space区，然后把Eden Space和From Space区的对象释放掉。当GC轮训扫描To Space区一定次数后，把依然存活的对象复制到老年代，然后释放To Space区的对象。 对于用可达性分析法搜索不到的对象，GC并不一定会回收该对象。要完全回收一个对象，至少需要经过两次标记的过程。 第一次标记：对于一个没有其他引用的对象，筛选该对象是否有必要执行finalize()方法，如果没有执行必要，则意味可直接回收。（筛选依据：是否复写或执行过finalize()方法；因为finalize方法只能被执行一次）。 第二次标记：如果被筛选判定位有必要执行，则会放入FQueue队列，并自动创建一个低优先级的finalize线程来执行释放操作。如果在一个对象释放前被其他对象引用，则该对象会被移除FQueue队列。 四、GC过程中用到的回收算法：通过上面的GC过程不难看出，Java堆中的年轻代和老年代采用了不同的回收算法。年轻代采用了复制法；而老年代采用了标记-整理法。 复制算法：因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。 标记整理法：复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。标记整理法其实是复制算法的优化，因为在老年代中，每次只有少量对象被回收，大量对象不被回收。和复制算法类似，但不同的是，在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。 五、Minor GC ，Full GC 触发条件Minor GC触发条件：当Eden区满时，触发Minor GC。 Full GC触发条件： （1）调用System.gc时，系统建议执行Full GC，但是不必然执行 （2）老年代空间不足 （3）方法去空间不足 （4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存 （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>GC</tag>
        <tag>垃圾回收机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础概念]]></title>
    <url>%2F2019%2F05%2F29%2FJava%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[一、重载在一个程序中，可以定义多个名称相同的方法，但是参数的类型或个数必须不同。 二、重写子类在继承父类方法的时候，有时候需要对父类的方法进行一些修改，这就是重写。需要相同的方法名，参数列表和返回值类型。子类在重写父类方法时，不能比父类的方法权限更严格，比如父类方法是Public，子类方法就不能是private。在子类中，用super关键字访问父类的成员。(super.成员变量，super.成员方法) 三、递归方法的递归是指在一个方法的内部调用自身的过程。递归必须要有结束条件，不然会陷入无限递归的状态。 四、数组int[] x = new int[100]上面代码的意思是，先声明一个变量x，该变量为一个int类型的数组。变量x回占用一块内存单元，它没有被分配初始值。然后创建一个数组，将数组的地址赋给x，这时内存中的状态才会发生变化。该数组中有100个元素，初始值都为0，每一个元素都有一个索引，最小的是0，最大的是99，也就是数组的长度-1。 五、八大基本数据类型整数型四种(int，byte，short，long)浮点型两种(float，double)字符型(char)布尔型(boolean) String 类型不是基本数据类型，属于引用数据类型，它实际上是final修饰，所以也不可以继承。区别:基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的。 六、面向对象的概念我理解的意思差不多就是，我们用对象来对应我们的现实中的事物，用对象的关系来描述事物之间的关系，这种思想，就是面向对象。 面向对象的特点是，封装性，继承性，多态性。 1. 封装性将对象的属性和行为封装起来，不需要让外界知道具体的实现细节。 2. 继承性继承性主要是描述类于类之间的关系。通过继承，我们可以无需编写原有类，对原有类的功能进行扩展。 3. 多态类指程序中允许出现重名现象，但不同的参数可以表现出不同的行为。 七、构造方法构造方法满足的条件：方法名与类名要相同在方法名的前面没有返回值类型的声明在方法中不能使用return语句返回一个值 当一个类被实例化后，会自动调用该类的构造方法。 构造方法也可以重载，根据传入参数的不同，分别调用不同的构造方法。 八、this关键字this关键字有三种使用方法。 1. 在方法里使用this调用类的成员变量，解决与局部变量名称冲突的问题。123456789class person&#123;int age;public person(int age)&#123;this.age = age;&#125;public int getAge()&#123;return this.age;&#125;&#125; 2. 在一个方法里，通过this关键字调用同一个类的另一个成员方法123456public void a()&#123;...&#125;public void b()&#123;this.a();&#125; 3.使用this调用类的构造方法，要注意：只能在构造方法里才能使用this调用其他的构造方法，而且this调用构造方法的语句必须在第一句，只能出现一次。九、static关键字static用于修饰类的成员，比如成员变量，成员方法，还有代码块。 1. 静态变量用static修饰的成员变量，称为静态变量。被所有实例共享。用 类名.变量名 来访问。static只能修饰成员变量，不能修饰局部变量。 2. 静态方法静态方法可以不用实例化对象，就可以访问。类名.方法名() 这样就可以访问了。当然也可以实例化再访问。 3. 静态代码块使用一个{}包围起来的代码被称为一个代码块。用static修饰的代码块称为静态代码块。如：123static&#123;sout(&quot;hhh&quot;);&#125; 这样。加载类的同时会执行该类的静态代码块，而且只有这个类在第一次被使用时才会加载。 十、内部类在一个类的内部定义类，这样的类称为内部类。这个内部类所在的类被称为外部类。内部类又分三种，成员内部类，静态内部类，方法内部类。 1. 成员内部类就是在一个类中再定义一个类，普通的类。内部类可以在外部类中被使用，并且能访问外部类的成员。但如果想通过外部类去访问内部类，则需要通过外部类的对象去创建内部类对象。如：12Outer.Inner inner = new Outer().new Inner()inner.show() 2. 静态内部类用static来修饰成员内部类，那么该内部类就被称为静态内部类。它可以在不创建外部类对象的情况下被实例化。12Outer.Inner inner = new Outer.Inner();inner.show(); 静态内部类中只能访问外部类的静态成员。在静态内部类中可以定义的静态的成员，而在非静态内部类中不能定义静态成员。 3. 方法内部类方法内部类，是指在成员方法中定义的类，它只能在当前方法中被使用。1234567891011121314public void test()&#123; class Inner&#123; void show&#123; sout(&quot;ggg&quot;); &#125; &#125; Inner in = new Inner(); in.show();&#125;main()&#123;Outer outer = new Outer();outer.test();&#125; 方法内部类，只能在方法中创建该类的实例对象并调用show()方法。方法内部类中也可以访问外部类的成员变量。 十一、类的继承类的继承指在一个现有类的基础上去构建一个新的类，构建出来的新类被称为子类，现有类被称为父类。用 extends 关键字来声明。 需要注意：在Java中，类只支持单继承，不允许多重继承多个类可以继承同一个父类可以多层继承，B继承A，C继承B子类在实例化时，会默认调用父类无参的构造方法 十二、final关键字final关键字用来修饰类，方法和变量。 修饰类时，该类将不可被继承修饰一个类的方法时，那么这个类的子类将不能重写该方法修饰变量时，那这个变量只能被赋值一次，而且需要在声明的时候赋予值，这个值将不能被修改 十三、抽象类与接口抽象类抽象类，就是类的抽象。我们知道类是客观事物的抽象，而抽象类又是类的进一步抽象。 举个例子： 猫，狗，鸡。这三个动物都会叫，但每个动物叫的声音都不一样。我们把猫，狗，鸡这三个动物都抽象为类，每个类都有一个叫的方法，那么猫的方法输出就是喵，狗输出的是汪，鸡输出的是喳。这个时候我们就可以把这三个类，在进行一次抽象，筛选出他们的共同点，叫。然后这三个类，都继承这个抽象类，然后实现这个叫的方法。 1）抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。 2）抽象类不能用来创建对象； 3）如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。 4) 包含抽象方法的类，必须声明为抽象类 接口更方便的对一个事物的功能进行拓展。是一种极度抽象的类型，它比抽象类更加“抽象”。 接口中可以含有 变量和方法。但，接口中的变量会被指定为public static final变量，而方法会被指定为public abstract方法且只能是public abstract方法，并且接口中所有的方法不能有具体的实现，也就是说，接口中的方法必须都是抽象方法，并且一般情况下不在接口中定义变量。 抽象类与接口的区别1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 2、抽象类要被子类继承，接口要被类实现。 3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 4、接口里定义的变量只能是公共的静态的常量（public,static,final），抽象类中的变量可以是成员变量或者静态变量。 5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。 7、抽象类里可以没有抽象方法 8、如果一个类里有抽象方法，那么这个类只能是抽象类 9、抽象方法要被实现，所以不能是静态的，也不能是私有的（静态的变量或者方法是全局可用，可以被继承，但不能被重写。也就相应的不存在被实现）。 10、接口可继承接口，并可多继承接口，但类只能单根继承。]]></content>
      <categories>
        <category>面试</category>
        <category>Java基础概念</category>
      </categories>
      <tags>
        <tag>Java基础概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OO音乐网站总结]]></title>
    <url>%2F2019%2F05%2F28%2FOO%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这是上学期学完SSM后，自己写的一个音乐网站，拿来练手用的。音乐网站的一些基本功能，基本实现了。但是有的功能，实现的方式比较麻烦，还能有改善的空间。马上准备面试了，所以打算重写看一下代码，以免时间长，忘记了 。 一、数据库1. user(用户信息表)存储基本的用户信息，用户名，密码，头像，网名。 2. song(歌表)、songsheet(歌单表)、sstos(歌单对应的歌表)song：歌名，歌的地址，封面，歌曲播放的次数，歌手，所属专辑(这个我没弄) songsheet：歌单名，创建歌单的用户，用户的id，封面，创建的时间 sstos：歌单id，歌曲id 3. 歌手表因为我没有弄歌手的主页，所以歌手表很简单，就一个歌手的id，歌手名，歌手图片。 4. comentary(主评论表)、reply(从评论表)当时弄这个评论回复的功能弄了好久，试了好几种方式，最后都实现不了，总是出问题，是评论显示的问题，就是我没有办法，让每条评论的评论显示在它的评论下。最后终于想到一个解决方案，建立一个主评论表，用来放每首歌下的显示的评论，或者说是评论歌曲的。然后建另外一个表，从评论表，用来放回复评论的，这个表里有一个属性，是回复的哪一个评论的id，这样，我就能把回复评论和评论相互对应起来，然后显示出来。总之，这个功能费了我很大的功夫。 comentary：主评论的id，评论的内容，评论的时间，评论歌曲的id，评论用户的id reply：回复的哪一个主评论的id，回复的内容，回复哪个用户的id，回复用户的id，评论状态，评论哪条评论的内容 需要特殊说明一个属性，是r_status(评论状态)，这是用作消息提示功能的，根据这个的值，来判断这条评论是否被查看。 5. collectss(歌单收藏表)用户id，歌单id 6. attention(关注表)用户id,关注的人的id 二、业务功能1. 评论提示功能描述：当别人回复你的评论后，你的头像旁边的邮件，会显示别人给你评论的个数，然后你点邮件进去，这个个数会重新归为0。然后你可以在这个页面，查看别人给你的评论，然后进行回复。 主要实现：12345678&lt;c:set var=&quot;mes&quot; value=&quot;0&quot;&gt;&lt;/c:set&gt;&lt;c:forEach items=&quot;$&#123;replyList&#125;&quot; var=&quot;reply&quot;&gt; &lt;c:forEach items=&quot;$&#123;reply.userList&#125;&quot; var=&quot;ru&quot;&gt; &lt;c:if test=&quot;$&#123;reply.r_onid == user.id &amp;&amp; reply.r_status == 1&#125;&quot;&gt; &lt;c:set var=&quot;mes&quot; value=&quot;$&#123;mes+1&#125;&quot;&gt;&lt;/c:set&gt; &lt;/c:if&gt; &lt;/c:forEach&gt;&lt;/c:forEach&gt; 其实这就是个思路，主要是reply表里，建一个r_status属性。先判断被回复的用户id，是不是和登陆用户id相同，然后判断这个评论的状态是不是为1，为1的话就是还没有查看，这时就会给mes+1。然后显示。 2. 登陆注册功能登陆注册功能使用了Bootstrap的模态框，点击右上方的登陆，跳出来登录框，进行登陆。注册在登陆框的下方，点击注册，登陆框会消失，然后弹出注册框。这是通过js来实现的。 1234567891011121314151617function openLogin()&#123; document.getElementById(&quot;win&quot;).style.display=&quot;&quot;;&#125;function closeLogin()&#123; document.getElementById(&quot;win&quot;).style.display=&quot;none&quot;;&#125;function openReg()&#123; document.getElementById(&quot;win&quot;).style.display=&quot;none&quot;; document.getElementById(&quot;reg&quot;).style.display=&quot;&quot;;&#125;function closeReg()&#123; document.getElementById(&quot;reg&quot;).style.display=&quot;none&quot;;&#125;function returnLogin()&#123; document.getElementById(&quot;reg&quot;).style.display=&quot;none&quot;; document.getElementById(&quot;win&quot;).style.display=&quot;&quot;;&#125; 这段代码，是用来控制，登陆和注册这两个模态框的互相切换，还用模态框的自由拖拽。当时给我整的有点头疼，总是出问题。 然后，注册的时候，有一个简单的前台验证。123456789101112131415function check() &#123; var password = $(&quot;#userpass&quot;).val(); var password2 = $(&quot;#password&quot;).val(); if(password == password2) &#123; $(&quot;#tishi&quot;).html(&quot;两次密码相同&quot;); $(&quot;#tishi&quot;).css(&quot;color&quot;,&quot;green&quot;); $(&quot;button&quot;).removeAttr(&quot;disabled&quot;,&quot;disabled&quot;); &#125; else &#123; $(&quot;#tishi&quot;).html(&quot;两次密码不相同&quot;); $(&quot;#tishi&quot;).css(&quot;color&quot;,&quot;red&quot;); $(&quot;button&quot;).attr(&quot;disabled&quot;,&quot;disabled&quot;); &#125; &#125; 3. 创建歌单和收藏歌曲创建歌单这个功能很简单，就不说了。 收藏歌曲，这个当时我感到麻烦的地方，就是，在模态框里，通过ajax显示出用户所创建的歌单，然后在提交。 解决方法：123456789101112131415function getArticles(ele) &#123; $(ele).empty(); $.ajax(&#123; url:&quot;$&#123;pageContext.request.contextPath &#125;/ss/ajaxSongsheet.action&quot;, type:&quot;GET&quot;, success:function (result) &#123; //console.log(result); $.each(result.extend.songsheetList, function () &#123; var optionEle = $(&quot;&lt;option&gt;&lt;/option&gt;&quot;) .append(this.ss_name).attr(&quot;value&quot;,this.ss_id); optionEle.appendTo(ele); &#125;); &#125; &#125;); &#125; 通过ajax,后台获取，然后前台展示。所以我感觉js是我的一个问题，目前掌握的还不够熟练。 4. 评论回复功能这个功能折磨了我好久，我一直想用ajax做出那种异步的效果，js不好的我，让我在这个功能上探索了很久。 前面提到过，主要建立两个表，这样就能在打开歌曲页面的时候，将对歌曲的评论展示出来，然后在点击展开评论的时候，通过该评论的Id,查询出这条评论下的回复。麻烦的是取值和前台显示。]]></content>
      <categories>
        <category>面试</category>
        <category>项目总结</category>
      </categories>
      <tags>
        <tag>音乐网站</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器]]></title>
    <url>%2F2019%2F05%2F26%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Iterator接口实现代码： 1234567891011ArrayList list = new ArrayList();list.add(&quot;data1&quot;);list.add(&quot;data2&quot;);list.add(&quot;data3&quot;);list.add(&quot;data4&quot;);list.add(&quot;data5&quot;);Iterator it = list.iterator();while(it.hasNext())&#123; Object obj = it.next(); System.out.println(obj);&#125; 首先使用调用ArrayList集合的iterator()方法获得迭代器对象，然后使用hasNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。在通过next()方法取元素时，必须保证要获取的元素存在，否则，会抛出异常。 需要说明的是，当通过迭代器获取ArrayList集合中的元素时，都会将这些元素当作Object类型来看待，如果想得到特定类型的元素，则需要进行强制类型转换。 foreach循环虽然Iterator可以用来遍历集合中的元素，但写法上比较繁琐，为了简化书写，从JDK5.0开始，提供了foreach循环。 实现代码： 123456789ArrayList list = new ArrayList();list.add(&quot;data1&quot;);list.add(&quot;data2&quot;);list.add(&quot;data3&quot;);list.add(&quot;data4&quot;);list.add(&quot;data5&quot;);for(Object obj : list)&#123; System.out.println(obj);&#125; 注意：当使用foreach循环遍历集合和数组时，只能访问集合中的元素，不能对其中的元素进行修改。 ListIterator接口实现代码： 1234567891011ArrayList list = new ArrayList();list.add(&quot;data1&quot;);list.add(&quot;data2&quot;);list.add(&quot;data3&quot;);list.add(&quot;data4&quot;);list.add(&quot;data5&quot;);ListIterator it = list.ListIterator();while(it.hasPrevious())&#123; Object obj = it.previous(); System.out.println(obj+&quot; &quot;);&#125; Iterator迭代器通过hasNext()方法和next()方法，迭代的方向是从集合中的第一个元素向最后一个元素迭代，就是所谓的正向迭代。 ListIterator正好相反，是用hasPrevious()和previous()方法来进行反向迭代。 需要注意的是， ListIterator迭代器只能用于List集合。 Enumeration接口实现代码： 1234567891011Vector v = new Vector();list.add(&quot;data1&quot;);list.add(&quot;data2&quot;);list.add(&quot;data3&quot;);list.add(&quot;data4&quot;);list.add(&quot;data5&quot;);Enumeration en = v.elements();while(en.hasMoreElements())&#123; Object obj = en.nextElement(); System.out.println(obj);&#125; 这是Vector集合提供的一个方法，Vector集合前面讲过，就不细说了。]]></content>
      <categories>
        <category>集合类</category>
        <category>迭代器</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List接口]]></title>
    <url>%2F2019%2F05%2F26%2FList%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[List接口继承自Collection接口。在List集合中允许出现重复的元素，所有的元素是以一种线性的元素存储的。 ArrayList集合ArrayList是 List 接口的一个实现类。可以将 ArrayList集合看作是一个长度可变的数组。 由于 ArrayList集合的底层是使用一个数组来保存元素，在增加和删除元素时，会导致创建新的数组，效率比较低，所有不适合做大量的增删操作。 但这种数组的结构允许程序通过索引的方式来访问元素，因此使用ArrayList集合查找元素很方便。 LinkedList集合LinkedList集合内部维护了一个双向循环链表。 链表中的每一个元素都使用引用的方式来记住它的前一个和后一个元素，从而可以将所有的元素连接起来。 所以LinkedList集合对于元素的增删操作具有很高的效率。 Vector集合在书上是这样描述 Vector集合的：用法和 ArrayList 完全一样，区别在于 Vector集合是线程安全的，而 ArrayList集合是线程不安全的。 所以我去搜了下 Vector集合是如何实现线程安全的。然后发现 Vector集合并不是绝对的线程安全，至少在进行复合操作时，并不是线程安全的。 举个栗子： 123456789101112131415161718192021222324252627282930public class App &#123; public static void main(String[] args) &#123; // ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); Vector&lt;String&gt; list = new Vector&lt;&gt;(); list.add(&quot;1&quot;); list.add(&quot;2&quot;); new Thread(new Runnable() &#123; public void run() &#123; //集合大小 int len = list.size(); try &#123; //睡5s Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //删除最后一个 list.remove(len-1); &#125; &#125;, &quot;t1&quot;).start(); new Thread(new Runnable() &#123; public void run() &#123; //清空集合 list.clear(); &#125; &#125;, &quot;t2&quot;).start(); &#125;&#125; 运行报错，分析原因： 线程t1先执行,获取到的list的size为2, 暂停5s, 线程t2开始执行, 清空list集合, 线程t1休眠时间结束,此时再删除就出现数组越界.因为数据已清空. 线程t1执行list.size()方法,此时线程t1持有list对象锁.其他线程等待. 线程t1执行完list.size方法之后会释放list对象锁. 之后进入休眠. 线程t2获取list对象锁后, 遍可以操作list, 而一旦线程t2操作了list对象, 那数组越界问题就出现了. 所以说, list.size 跟 list.remove 这2个方法单独操作时,是线程安全的。一旦同时操作,那vector就不是大家所认为的线程安全操作了. 解决方法，可以尝试加锁： 123456public void deleteLast() &#123; synchronized (v) &#123; int index = v.size() - 1; v.remove(index); &#125;&#125; 如上，对v进行加锁，即可保证同一时刻，不会有其他线程删除掉v中的元素。 总结：中的所有自带方法都是线程安全的，因为方法都使用synchronized关键字标注。但是，对这些集合类的复合操作无法保证其线程安全性。需要客户端通过主动加锁来保证。]]></content>
      <categories>
        <category>集合类</category>
        <category>List接口</category>
      </categories>
      <tags>
        <tag>ArrayList集合</tag>
        <tag>LinkedList集合</tag>
        <tag>Vector集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AspectJ注解]]></title>
    <url>%2F2019%2F05%2F14%2FAspectJ%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[AspectJ 支持 5 种类型的通知注解:@Before: 前置通知, 在方法执行之前执行 @After: 后置通知, 在方法执行之后执行 @AfterRunning: 返回通知, 在方法返回结果之后执行 @AfterThrowing: 异常通知, 在方法抛出异常之后 @Around: 环绕通知, 围绕着方法执行 有篇博文将这5个通知方法的使用做了具体的代码实现，我就不一一解释了。具体请看这篇文章，解释的非常清楚：https://blog.csdn.net/qq_22899021/article/details/82496508]]></content>
      <categories>
        <category>Spring</category>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>AspectJ注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[切入点表达式]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为了能够灵活定义切入点位置，Spring AOP提供了多种切入点指示符。 execution———用来匹配执行方法的连接点语法结构： execution( 方法修饰符 方法返回值 方法所属类 匹配方法名 ( 方法中的形参表 ) 方法申明抛出的异常 ) 其中红色字体的部分时不能省略的，各部分都支持通配符 “*” 来匹配全部。 比较特殊的为形参表部分，其支持两种通配符: “*”：代表一个任意类型的参数； “..”：代表零个或多个任意类型的参数。 例如： （）匹配一个无参方法 （..）匹配一个可接受任意数量参数和类型的方法 （*）匹配一个接受一个任意类型参数的方法 （*，Integer）匹配一个接受两个参数的方法，第一个可以为任意类型，第二个必须为Integer。 下图是一些execution的使用实例： within————通过类匹配模式申明切入点（只能通过类型匹配连接点）例如：within(aop_part..*) 表示匹配包aop_part以及子包的所有方法 由于execution可以匹配包、类、方法，而within只能匹配包、类，因此execution完全可以代替within的功能。 this————限定AOP代理必须时指定类型的实例，用于匹配该对象的所有连接点例如：this(aop_part.service.GodService) 表示匹配了GodService接口的代理对象的所有连接点 target————通过判断目标类的类型确定判断的是否匹配this通过判断代理类的类型来决定是否和切入点匹配，两者限定的对象都是指定类型的实例。 例如: target(aop_part.service.GodService) 表示匹配实现了GodService接口的目标对象的所有连接点 args————用于对连接点的参数类型进行限制，要求参数类型时指定类型的实例例如：args(aop_part.service) 表示匹配时，出入的参数类型时service的方法 其与execution(**(aop_part.service))的区别为，execution针对的时方法签名，而args针对的是运行时的实际参数类型。 例： args既匹配buyGoods(service newService)，也匹配buyGoods(Buyservice newService) &lt;Buyservice为service的子类&gt; execution只匹配buyGoods(service newService) 组合切入点支持 &amp;&amp;、 || 、！ 与其他语言所代表的意思相同 例：args(aop_part.service) &amp;&amp;execution(**(aop_part.service))]]></content>
      <categories>
        <category>Spring</category>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>切入点表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用SpringAOP]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8SpringAOP%2F</url>
    <content type="text"><![CDATA[Spring 提供了很多的实现AOP的方式，今天具体写出这三种实现方式：Spring 接口方式，schema配置方式和注解方式。 方式一：AOP接口利用Spring AOP接口实现AOP，主要是为了指定自定义通知来供spring AOP机制识别。主要接口：前置通知 MethodBeforeAdvice ，后置通知：AfterReturningAdvice，环绕通知：MethodInterceptor，异常通知：ThrowsAdvice 。见例子代码： a、业务接口： 123456789101112131415161718192021222324252627282930313233343536/** * 代理类接口，也是业务类接口&lt;br&gt; * * 利用接口的方式，spring aop 将默认通过jdk 动态代理来实现代理类&lt;br&gt; * 不利用接口，则spring aop 将通过cglib 来实现代理类 * * @author yanbin * */public interface IBaseBusiness &#123; /** * 用作代理的切入点方法 * * @param obj * @return */ public String delete(String obj); /** * 这方法不被切面切 * * @param obj * @return */ public String add(String obj); /** * 这方法切不切呢？可以设置 * * @param obj * @return */ public String modify(String obj);&#125; b、业务类： 123456789101112131415161718192021222324252627/** * 业务类，也是目标对象 * * @author yanbin * */public class BaseBusiness implements IBaseBusiness &#123; /** * 切入点 */ public String delete(String obj) &#123; System.out.println(&quot;==========调用切入点：&quot; + obj + &quot;说：你敢删除我！===========\n&quot;); return obj + &quot;：瞄～&quot;; &#125; public String add(String obj) &#123; System.out.println(&quot;================这个方法不能被切。。。============== \n&quot;); return obj + &quot;：瞄～ 嘿嘿！&quot;; &#125; public String modify(String obj) &#123; System.out.println(&quot;=================这个也设置加入切吧====================\n&quot;); return obj + &quot;：瞄改瞄啊！&quot;; &#125;&#125; c、通知类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 前置通知。 * * @author yanbin * */public class BaseBeforeAdvice implements MethodBeforeAdvice &#123; /** * method : 切入的方法 &lt;br&gt; * args ：切入方法的参数 &lt;br&gt; * target ：目标对象 */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;===========进入beforeAdvice()============ \n&quot;); System.out.print(&quot;准备在&quot; + target + &quot;对象上用&quot;); System.out.print(method + &quot;方法进行对 &apos;&quot;); System.out.print(args[0] + &quot;&apos;进行删除！\n\n&quot;); System.out.println(&quot;要进入切入点方法了 \n&quot;); &#125;&#125;/** * 后置通知 * * @author yanbin * */public class BaseAfterReturnAdvice implements AfterReturningAdvice &#123; /** * returnValue ：切入点执行完方法的返回值，但不能修改 &lt;br&gt; * method ：切入点方法 &lt;br&gt; * args ：切入点方法的参数数组 &lt;br&gt; * target ：目标对象 */ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;==========进入afterReturning()=========== \n&quot;); System.out.println(&quot;切入点方法执行完了 \n&quot;); System.out.print(args[0] + &quot;在&quot;); System.out.print(target + &quot;对象上被&quot;); System.out.print(method + &quot;方法删除了&quot;); System.out.print(&quot;只留下：&quot; + returnValue + &quot;\n\n&quot;); &#125;&#125;/** * 环绕通知 * * @author yanbin * */public class BaseAroundAdvice implements MethodInterceptor &#123; /** * invocation ：连接点 */ @Override public Object invoke(MethodInvocation invocation) throws Throwable &#123; System.out.println(&quot;===========进入around环绕方法！=========== \n&quot;); // 调用目标方法之前执行的动作 System.out.println(&quot;调用方法之前: 执行！\n&quot;); // 调用方法的参数 Object[] args = invocation.getArguments(); // 调用的方法 Method method = invocation.getMethod(); // 获取目标对象 Object target = invocation.getThis(); // 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行 Object returnValue = invocation.proceed(); System.out.println(&quot;===========结束进入around环绕方法！=========== \n&quot;); System.out.println(&quot;输出：&quot; + args[0] + &quot;;&quot; + method + &quot;;&quot; + target + &quot;;&quot; + returnValue + &quot;\n&quot;); System.out.println(&quot;调用方法结束：之后执行！\n&quot;); return returnValue; &#125;&#125;/** * 异常通知，接口没有包含任何方法。通知方法自定义 * * @author yanbin * */public class BaseAfterThrowsAdvice implements ThrowsAdvice &#123; /** * 通知方法，需要按照这种格式书写 * * @param method * 可选：切入的方法 * @param args * 可选：切入的方法的参数 * @param target * 可选：目标对象 * @param throwable * 必填 : 异常子类，出现这个异常类的子类，则会进入这个通知。 */ public void afterThrowing(Method method, Object[] args, Object target, Throwable throwable) &#123; System.out.println(&quot;删除出错啦&quot;); &#125;&#125; d、定义指定切点： 1234567891011121314151617181920212223242526272829/** * 定义一个切点，指定对应方法匹配。来供切面来针对方法进行处理&lt;br&gt; * * 继承NameMatchMethodPointcut类，来用方法名匹配 * * @author yanbin * */public class Pointcut extends NameMatchMethodPointcut &#123; private static final long serialVersionUID = 3990456017285944475L; @SuppressWarnings(&quot;rawtypes&quot;) @Override public boolean matches(Method method, Class targetClass) &#123; // 设置单个方法匹配 this.setMappedName(&quot;delete&quot;); // 设置多个方法匹配 String[] methods = &#123; &quot;delete&quot;, &quot;modify&quot; &#125;; //也可以用“ * ” 来做匹配符号 // this.setMappedName(&quot;get*&quot;); this.setMappedNames(methods); return super.matches(method, targetClass); &#125;&#125; e、配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot; default-autowire=&quot;byName&quot;&gt; &lt;!-- ==============================利用spring自己的aop配置================================ --&gt; &lt;!-- 声明一个业务类 --&gt; &lt;bean id=&quot;baseBusiness&quot; class=&quot;aop.base.BaseBusiness&quot; /&gt; &lt;!-- 声明通知类 --&gt; &lt;bean id=&quot;baseBefore&quot; class=&quot;aop.base.advice.BaseBeforeAdvice&quot; /&gt; &lt;bean id=&quot;baseAfterReturn&quot; class=&quot;aop.base.advice.BaseAfterReturnAdvice&quot; /&gt; &lt;bean id=&quot;baseAfterThrows&quot; class=&quot;aop.base.advice.BaseAfterThrowsAdvice&quot; /&gt; &lt;bean id=&quot;baseAround&quot; class=&quot;aop.base.advice.BaseAroundAdvice&quot; /&gt; &lt;!-- 指定切点匹配类 --&gt; &lt;bean id=&quot;pointcut&quot; class=&quot;aop.base.pointcut.Pointcut&quot; /&gt; &lt;!-- 包装通知，指定切点 --&gt; &lt;bean id=&quot;matchBeforeAdvisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;&gt; &lt;property name=&quot;pointcut&quot;&gt; &lt;ref bean=&quot;pointcut&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;advice&quot;&gt; &lt;ref bean=&quot;baseBefore&quot; /&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 使用ProxyFactoryBean 产生代理对象 --&gt; &lt;bean id=&quot;businessProxy&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt; &lt;!-- 代理对象所实现的接口 ，如果有接口可以这样设置 --&gt; &lt;property name=&quot;proxyInterfaces&quot;&gt; &lt;value&gt;aop.base.IBaseBusiness&lt;/value&gt; &lt;/property&gt; &lt;!-- 设置目标对象 --&gt; &lt;property name=&quot;target&quot;&gt; &lt;ref local=&quot;baseBusiness&quot; /&gt; &lt;/property&gt; &lt;!-- 代理对象所使用的拦截器 --&gt; &lt;property name=&quot;interceptorNames&quot;&gt; &lt;list&gt; &lt;value&gt;matchBeforeAdvisor&lt;/value&gt; &lt;value&gt;baseAfterReturn&lt;/value&gt; &lt;value&gt;baseAround&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; f、测试类： 123456789public class Debug &#123;public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;aop/schema_aop.xml&quot;); IBaseBusiness business = (IBaseBusiness ) context.getBean(&quot;businessProxy&quot;); business.delete(&quot;猫&quot;); &#125;&#125; 具体的代码实现可以从代码注释中很容易理解 接口方式的实现。结果也可想而知，前置方法会在切入点方法之前执行，后置会在切入点方法执行之后执行，环绕则会在切入点方法执行前执行同事方法结束也会执行对应的部分。主要是调用proceed()方法来执行切入点方法。来作为环绕通知前后方法的分水岭。然后在实现的过程中，有几点却是可以细揣摩一下的。 可以看出在xml 配置 businessProxy这个bean的时候，ProxyFactoryBean类中指定了，proxyInterfaces参数。这里我把他配置了IBaseBusiness接口。因为在项目开发过程中，往往业务类都会有对应的接口，以方便利用IOC解耦。但Spring AOP却也能支持没有接口的代理。这就是为什么需要导入cglib.jar的包了。看过spring的源码，知道在目标切入对象如果有实现接口，spring会默认走jdk动态代理来实现代理类。如果没有接口，则会通过cglib来实现代理类。 这个业务类现在有 前置通知，后置通知，环绕三个通知同时作用，可能以及更多的通知进行作用。那么这些通知的执行顺序是怎么样的？就这个例子而言，同时实现了三个通知。在例子xml中，则显示执行before通知，然后执行around的前处理，执行切点方法，再执行return处理。最后执行around的后处理。经过测试，知道spring 处理顺序是按照xml配置顺序依次处理通知，以队列的方式存放前通知，以压栈的方式存放后通知。所以是前通知依次执行，后通知到切入点执行完之后，从栈里在后进先出的形式把后通知执行。 在实现过程中发现通知执行对应目标对象的整个类中的方法，如何精确到某个方法，则需要定义一个切点匹配的方式：spring提供了方法名匹配或正则方式来匹配。然后通过DefaultPointcutAdvisor来包装通知，指定切点。 利用方式一的配置起来，可见代码还是非常的厚重的，定义一个切面就要定义一个切面类，然而切面类中，就一个通知方法，着实没有必要。所以Spring提供了，依赖aspectj的schema配置和基于aspectj 注解方式。这两种方式非常简介方便使用，也是项目中普遍的使用方式。 方式二：schema配置a、业务类： 123456789101112131415161718192021222324252627/** * 业务类 * * @author yanbin * */public class AspectBusiness &#123; /** * 切入点 */ public String delete(String obj) &#123; System.out.println(&quot;==========调用切入点：&quot; + obj + &quot;说：你敢删除我！===========\n&quot;); return obj + &quot;：瞄～&quot;; &#125; public String add(String obj) &#123; System.out.println(&quot;================这个方法不能被切。。。============== \n&quot;); return obj + &quot;：瞄～ 嘿嘿！&quot;; &#125; public String modify(String obj) &#123; System.out.println(&quot;=================这个也设置加入切吧====================\n&quot;); return obj + &quot;：瞄改瞄啊！&quot;; &#125;&#125; b、切面类：切面类中，包含了所有的通知 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 定义一个切面 * * @author yanbin * */public class AspectAdvice &#123; /** * 前置通知 * * @param jp */ public void doBefore(JoinPoint jp) &#123; System.out.println(&quot;===========进入before advice============ \n&quot;); System.out.print(&quot;准备在&quot; + jp.getTarget().getClass() + &quot;对象上用&quot;); System.out.print(jp.getSignature().getName() + &quot;方法进行对 &apos;&quot;); System.out.print(jp.getArgs()[0] + &quot;&apos;进行删除！\n\n&quot;); System.out.println(&quot;要进入切入点方法了 \n&quot;); &#125; /** * 后置通知 * * @param jp * 连接点 * @param result * 返回值 */ public void doAfter(JoinPoint jp, String result) &#123; System.out.println(&quot;==========进入after advice=========== \n&quot;); System.out.println(&quot;切入点方法执行完了 \n&quot;); System.out.print(jp.getArgs()[0] + &quot;在&quot;); System.out.print(jp.getTarget().getClass() + &quot;对象上被&quot;); System.out.print(jp.getSignature().getName() + &quot;方法删除了&quot;); System.out.print(&quot;只留下：&quot; + result + &quot;\n\n&quot;); &#125; /** * 环绕通知 * * @param pjp * 连接点 */ public void doAround(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;===========进入around环绕方法！=========== \n&quot;); // 调用目标方法之前执行的动作 System.out.println(&quot;调用方法之前: 执行！\n&quot;); // 调用方法的参数 Object[] args = pjp.getArgs(); // 调用的方法名 String method = pjp.getSignature().getName(); // 获取目标对象 Object target = pjp.getTarget(); // 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行 Object result = pjp.proceed(); System.out.println(&quot;输出：&quot; + args[0] + &quot;;&quot; + method + &quot;;&quot; + target + &quot;;&quot; + result + &quot;\n&quot;); System.out.println(&quot;调用方法结束：之后执行！\n&quot;); &#125; /** * 异常通知 * * @param jp * @param e */ public void doThrow(JoinPoint jp, Throwable e) &#123; System.out.println(&quot;删除出错啦&quot;); &#125;&#125; c、配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot; default-autowire=&quot;byName&quot;&gt; &lt;!-- ==============================利用spring 利用aspectj来配置AOP================================ --&gt; &lt;!-- 声明一个业务类 --&gt; &lt;bean id=&quot;aspectBusiness&quot; class=&quot;aop.schema.AspectBusiness&quot; /&gt; &lt;!-- 声明通知类 --&gt; &lt;bean id=&quot;aspectAdvice&quot; class=&quot;aop.schema.advice.AspectAdvice&quot; /&gt; &lt;aop:config&gt; &lt;aop:aspect id=&quot;businessAspect&quot; ref=&quot;aspectAdvice&quot;&gt; &lt;!-- 配置指定切入的对象 --&gt; &lt;aop:pointcut id=&quot;point_cut&quot; expression=&quot;execution(* aop.schema.*.*(..))&quot; /&gt; &lt;!-- 只匹配add方法作为切入点 &lt;aop:pointcut id=&quot;except_add&quot; expression=&quot;execution(* aop.schema.*.add(..))&quot; /&gt; --&gt; &lt;!-- 前置通知 --&gt; &lt;aop:before method=&quot;doBefore&quot; pointcut-ref=&quot;point_cut&quot; /&gt; &lt;!-- 后置通知 returning指定返回参数 --&gt; &lt;aop:after-returning method=&quot;doAfter&quot; pointcut-ref=&quot;point_cut&quot; returning=&quot;result&quot; /&gt; &lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;point_cut&quot;/&gt; &lt;aop:after-throwing method=&quot;doThrow&quot; pointcut-ref=&quot;point_cut&quot; throwing=&quot;e&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; d、测试类： 123456789public class Debug &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;aop/schema_aop.xml&quot;); AspectBusiness business = (AspectBusiness) context.getBean(&quot;aspectBusiness&quot;); business.delete(&quot;猫&quot;); &#125;&#125; 方式三：aspectj注解注解在项目中已经到处都是了，撇开一些优劣不提，开发的便利性和可读性是非常的方便的。用来配置Spring AOP也非常简单便利。 a、业务类： 12345678910111213141516171819202122232425262728/** * 业务类 * * @author yanbin * */@Componentpublic class Business &#123; /** * 切入点 */ public String delete(String obj) &#123; System.out.println(&quot;==========调用切入点：&quot; + obj + &quot;说：你敢删除我！===========\n&quot;); return obj + &quot;：瞄～&quot;; &#125; public String add(String obj) &#123; System.out.println(&quot;================这个方法不能被切。。。============== \n&quot;); return obj + &quot;：瞄～ 嘿嘿！&quot;; &#125; public String modify(String obj) &#123; System.out.println(&quot;=================这个也设置加入切吧====================\n&quot;); return obj + &quot;：瞄改瞄啊！&quot;; &#125;&#125; b、切面类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 定义切面 * * @Aspect : 标记为切面类 * @Pointcut : 指定匹配切点 * @Before : 指定前置通知，value中指定切入点匹配 * @AfterReturning ：后置通知，具有可以指定返回值 * @AfterThrowing ：异常通知 * * @author yanbin * */@Component@Aspectpublic class AspectAdvice &#123; /** * 指定切入点匹配表达式，注意它是以方法的形式进行声明的。 */ @Pointcut(&quot;execution(* aop.annotation.*.*(..))&quot;) public void anyMethod() &#123; &#125; /** * 前置通知 * * @param jp */ @Before(value = &quot;execution(* aop.annotation.*.*(..))&quot;) public void doBefore(JoinPoint jp) &#123; System.out.println(&quot;===========进入before advice============ \n&quot;); System.out.print(&quot;准备在&quot; + jp.getTarget().getClass() + &quot;对象上用&quot;); System.out.print(jp.getSignature().getName() + &quot;方法进行对 &apos;&quot;); System.out.print(jp.getArgs()[0] + &quot;&apos;进行删除！\n\n&quot;); System.out.println(&quot;要进入切入点方法了 \n&quot;); &#125; /** * 后置通知 * * @param jp * 连接点 * @param result * 返回值 */ @AfterReturning(value = &quot;anyMethod()&quot;, returning = &quot;result&quot;) public void doAfter(JoinPoint jp, String result) &#123; System.out.println(&quot;==========进入after advice=========== \n&quot;); System.out.println(&quot;切入点方法执行完了 \n&quot;); System.out.print(jp.getArgs()[0] + &quot;在&quot;); System.out.print(jp.getTarget().getClass() + &quot;对象上被&quot;); System.out.print(jp.getSignature().getName() + &quot;方法删除了&quot;); System.out.print(&quot;只留下：&quot; + result + &quot;\n\n&quot;); &#125; /** * 环绕通知 * * @param pjp * 连接点 */ @Around(value = &quot;execution(* aop.annotation.*.*(..))&quot;) public void doAround(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(&quot;===========进入around环绕方法！=========== \n&quot;); // 调用目标方法之前执行的动作 System.out.println(&quot;调用方法之前: 执行！\n&quot;); // 调用方法的参数 Object[] args = pjp.getArgs(); // 调用的方法名 String method = pjp.getSignature().getName(); // 获取目标对象 Object target = pjp.getTarget(); // 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行 Object result = pjp.proceed(); System.out.println(&quot;输出：&quot; + args[0] + &quot;;&quot; + method + &quot;;&quot; + target + &quot;;&quot; + result + &quot;\n&quot;); System.out.println(&quot;调用方法结束：之后执行！\n&quot;); &#125; /** * 异常通知 * * @param jp * @param e */ @AfterThrowing(value = &quot;execution(* aop.annotation.*.*(..))&quot;, throwing = &quot;e&quot;) public void doThrow(JoinPoint jp, Throwable e) &#123; System.out.println(&quot;删除出错啦&quot;); &#125;&#125; c、配置： 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&quot; default-autowire=&quot;byName&quot;&gt; &lt;context:component-scan base-package=&quot;aop.annotation&quot; /&gt; &lt;!-- 打开aop 注解 --&gt; &lt;aop:aspectj-autoproxy /&gt;&lt;/beans&gt; d、测试类： 12345678910111213141516/** * 测试类 * * @author yanbin * */public class Debug &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;aop/annotation_aop.xml&quot;); Business business = (Business) context.getBean(&quot;business&quot;); business.delete(&quot;猫&quot;); &#125;&#125; 里面有些地方涉及到的 AspectJ注解 和 切入点表达式，我另外在开文章写。]]></content>
      <categories>
        <category>Spring</category>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringAOP到底是什么]]></title>
    <url>%2F2019%2F05%2F14%2FSpringAOP%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[刚开始看这个AOP的时候，给我看的有点懵逼，术语太多，不理解是什么意思，对应的是什么过程。比如接合点的定义是：实际代码中的点，在这些点是执行“方面”，从而向应用程序中插入额外的逻辑。刚开始根本不知道在说啥，在网上一顿乱搜，找到了一篇通俗易懂的解释文章，感觉讲的不错。原文在此：https://blog.csdn.net/changudeng1992/article/details/80625134。 一、AOP到底是什么？切面编程，就是在你项目原有的功能基础上，通过AOP去添加新的功能，这些功能是建立在原有功能的基础上的，而且原有的功能并不知道你已经添加了新的功能。比如说，你去ATM取钱，取钱是一个功能，取完钱后向你的手机发送一条取钱信息，这就是新加的功能。 AOP就是在某一个类或方法执行前后打个标记，声明在执行到这里之前要先执行什么，执行完这里之后要接着执行什么。插入了新的执行方法。 当我们需要在许多类中添加相同逻辑（或记录等其他）代码的时候，一般我们编程会在每一个类中都写上这些代码。当需要修改的时候，我们又必须找出这些类来删除这些逻辑代码。这里，你觉不觉得有什么问题。这好像关系到复用的问题，那么可以用聚合或继承来完成？那么再继续下去，我们需要这些逻辑代码指定到类中的某个方法前面执行，或者在方法后面执行，又或者我想指定在类的某一个位置去执行它，那么这就不是复用的问题了，而是要修改类了，变成动态的了。那么就出现了aop这个概念-面向切面编程。 如上图，黑线为一个流程代码，红线为切入的代码。即在5个流程中固定位置插入了3个逻辑代码，如果你不需要的时候，你完全可以撤出红线代码，而要修改的话，也只需修改这三个类（红线）即可，因为主代码（黑线）和添加代码（红线）是没有耦合的，相当于插拔式的。而且spring aop支持声明式的配置，使得aop更加方便。 二、AOP术语的通俗解释1.通知（Advice）就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。 2.连接点（JoinPoint）这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。 3.切入点（Pointcut）上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。 4.切面（Aspect）切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。 5.引入（introduction）允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗 6.目标（target）引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。 7.代理(proxy)怎么实现整套aop机制的，都是通过代理，这个一会给细说。 8.织入(weaving)把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。 关键就是：切点定义了哪些连接点会得到通知 三、我所理解的aop原理spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。 具体的实现过程和两个代理机制（JDK代理和CGLIB代理），下次我会单独写一篇。]]></content>
      <categories>
        <category>Spring</category>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务管理]]></title>
    <url>%2F2019%2F05%2F13%2FSpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、理解事务管理任何处理数据的系统都必须保护数据的完整性。 事务有四个特性：ACID 原子性（Atomicity）： 事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。一致性（Consistency）： 一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。隔离性（Isolation）： 可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。持久性（Durability）： 一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。 二、Spring的事务抽象模型每种数据访问技术都有其事务机制。他们提供了不同的API来开始新事务，当数据操作完成后提交事务，或发生错误时回滚事务。Spring的事务抽象模型基于PlatformTransactionManager接口，并且存在不同的具体实现。 1.使用xml的方式进行事务管理12345678910111213141516171819202122&lt;!-- 注册配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置事务传播特性 --&gt; &lt;tx:advice id=&quot;transactionAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;load*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置哪些类的哪些方法参与事务 --&gt; &lt;aop:config&gt; &lt;aop:advisor pointcut=&quot;execution(* com.sdjz.eshop.service.*..*.*(..))&quot; advice-ref=&quot;transactionAdvice&quot; /&gt; &lt;/aop:config&gt; 2.使用注解的方式进行事务管理12345678//在spring配置文件中引入&lt;tx:&gt;命名空间&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd&quot;&gt; 123456 &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt;&lt;!-- 使用注解方式定义事务 --&gt; &lt;tx:annotation-driven proxy-target-class=&quot;true&quot; transaction-manager=&quot;transactionManager&quot; /&gt; 然后使用@Transactional来进行标记开启事务。 三、事务的传播行为和隔离级别当类中某些方法不需要事物时: 1234567891011@Transactionalpublic class TestServiceBean implements TestService &#123; private TestDao dao; public void setDao(TestDao dao) &#123; this.dao = dao; &#125; @Transactional(propagation = Propagation.NOT_SUPPORTED) public List&lt;Object&gt; getAll() &#123; return null; &#125; &#125; 其中的@Transactional(propagation = Propagation.NOT_SUPPORTED)便是传播行为的实现。 事物传播行为介绍: @Transactional(propagation=Propagation.REQUIRED)如果有事务, 那么加入事务, 没有的话新建一个(默认情况下) @Transactional(propagation=Propagation.NOT_SUPPORTED)容器不为这个方法开启事务 @Transactional(propagation=Propagation.REQUIRES_NEW)不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务 @Transactional(propagation=Propagation.MANDATORY)必须在一个已有的事务中执行,否则抛出异常 @Transactional(propagation=Propagation.NEVER)必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反) @Transactional(propagation=Propagation.SUPPORTS)如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务。 事物超时设置:@Transactional(timeout=30) //默认是30秒 事务隔离级别: @Transactional(isolation = Isolation.READ_UNCOMMITTED)读取未提交数据(会出现脏读, 不可重复读) 基本不使用 @Transactional(isolation = Isolation.READ_COMMITTED)读取已提交数据(会出现不可重复读和幻读) @Transactional(isolation = Isolation.REPEATABLE_READ)可重复读(会出现幻读) @Transactional(isolation = Isolation.SERIALIZABLE)串行化 脏读 : 一个事务读取到另一事务未提交的更新数据 不可重复读 : 在同一事务中, 多次读取同一数据返回的结果有所不同, 换句话说, 后续读取可以读到另一事务已提交的更新数据. 相反, “可重复读”在同一事务中多次。读取数据时, 能够保证所读数据一样, 也就是后续读取不能读到另一事务已提交的更新数据。 幻读 : 一个事务读到另一个事务已提交的insert数据。 注意的几点: 1、@Transactional 只能被应用到public方法上, 对于其它非public的方法,如果标记了@Transactional也不会报错,但方法没有事务功能. 2、用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw new RuntimeException(“注释”);)会回滚，即遇到不受检查（unchecked）的例外时回滚；而遇到需要捕获的例外(throw new Exception(“注释”);)不会回滚,即遇到受检查的例外（就是非运行时抛出的异常，编译器会检查到的异常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚 要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .如果让unchecked例外不回滚： @Transactional(notRollbackFor=RunTimeException.class)如下:123456789@Transactional(rollbackFor=Exception.class) //指定回滚,遇到异常Exception时回滚public void methodName() &#123;throw new Exception(&quot;注释&quot;);&#125;@Transactional(noRollbackFor=Exception.class)//指定不回滚,遇到运行期例外(throw new RuntimeException(&quot;注释&quot;);)会回滚public ItimDaoImpl getItemDaoImpl() &#123;throw new RuntimeException(&quot;注释&quot;);&#125; 3、@Transactional 注解应该只被应用到 public 可见度的方法上。 如果你在 protected、private 或者 package-visible 的方法上使用 @Transactional 注解，它也不会报错， 但是这个被注解的方法将不会展示已配置的事务设置。 4、@Transactional 注解可以被应用于接口定义和接口方法、类定义和类的 public 方法上。然而，请注意仅仅 @Transactional 注解的出现不足于开启事务行为，它仅仅 是一种元数据，能够被可以识别 @Transactional 注解和上述的配置适当的具有事务行为的beans所使用。上面的例子中，其实正是 tx:annotation-driven/元素的出现开启了事务行为。 5、Spring团队的建议是你在具体的类（或类的方法）上使用 @Transactional 注解，而不要使用在类所要实现的任何接口上。你当然可以在接口上使用 @Transactional 注解，但是这将只能当你设置了基于接口的代理时它才生效。因为注解是 不能继承 的，这就意味着如果你正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装（将被确认为严重的）。因 此，请接受Spring团队的建议并且在具体的类上使用 @Transactional 注解。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring管理的Bean]]></title>
    <url>%2F2019%2F05%2F13%2FSpring%E7%AE%A1%E7%90%86%E7%9A%84Bean%2F</url>
    <content type="text"><![CDATA[被Spring创建和管理的Java对象被称为Bean。这些对象都是POJO，但却在Spring容器中被管理。因此，也常把她们称为Spring管理的Bean。 1.命名BeanBean通过名称进行区分。每一个Bean至少有一个名称。如果没有给它命名，Spring容器将会为它分配一个内部名称。通过Bean的名称，可以从其他的Bean定义中或者用显示查找从应用程序代码中引用Bean。在基于XML的配置中，使用id属性将一个名称分配给Bean。在同一个XML文件中，不能复制同一个名称。然而，在其他XML文件中，可以将相同的名称分配给另一个Bean定义。这时，Bean重写机制开始发挥作用。 1&lt;bean name=&quot;accountDao,A,B&quot; class=&quot;com.mzh.test&quot;/&gt; 或者 123&lt;bean id=&quot;accountDao&quot; class=&quot;com.mzh.test&quot;/&gt;&lt;alias name=&quot;A&quot; alias=&quot;accountDao&quot;/&gt;&lt;alias name=&quot;B&quot; alias=&quot;accountDao&quot;/&gt; 2.Bean实例化方法一：调用相关类中一个可用的构造函数 二：调用可用的静态或实例工厂方法。 三：使用Spring自带的FactoryBean接口。 3.Bean作用域由Spring容器创建的Bean的生存期被称为Bean作用域。默认情况下，由Spring容器创建的所有Bean都是Singleton作用域。换句话说，针对一个Bean定义只创建了一个Bean实例，并且Spring容器可以在整个应用程序中使用该实例。当不同的Bean与不同的层（控制层、服务层和数据访问层）相对应时，可以使用Singleton作用域。此时创建的实例都是无状态实例，在同一时间服务于不同的请求。 Spring 3中为Bean定义了5中作用域，分别为singleton（单例）、prototype（原型）、request、session和global session，5种作用域说明如下： singleton: 单例模式，Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域，也可以显示的将Bean定义为singleton模式，配置为：1&lt;bean id=&quot;userDao&quot; class=&quot;com.ioc.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt; prototype: 原型模式，每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。 request： 在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。1&lt;bean id=&quot;loginAction&quot; class=&quot;com.cnblogs.Login&quot; scope=&quot;request&quot;/&gt;,针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。 session: 在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。1&lt;bean id=&quot;userPreference&quot; class=&quot;com.ioc.UserPreference&quot; scope=&quot;session&quot;/&gt;,同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。 global Session： 在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。 4.延迟初始化默认情况下，Spring容器在启动阶段创建Bean。该过程被称为预先Bean初始化。其优点是可以尽早发生配置错误。例如，在基于XML的配置中，Bean定义的类属性出现了错别字，或者引用了一个不可用的Bean定义等。但另一方面，如果存在大量的Bean定义或者一些特殊的Bean，那么初始化可能会降低启动速度。 如果将Bean配置为延迟创建，那么容器将会延迟Bean的创建，直到真正需要时才创建。通过从一个已经创建的另一个Bean中的引用，或者在应用程序代码中执行显示Bean查找，都可以触发Bean的创建。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring管理的Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用spring进行依赖注入]]></title>
    <url>%2F2019%2F05%2F13%2F%E4%BD%BF%E7%94%A8spring%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1.Spring IoC容器在这里，我们先不具体深入的了解Spring IoC容器，只需要知道它是做什么的。Spring的核心就是IoC容器，它的作用是可以在对象生成或初始化时直接将数据注入到对象中，也可以通过将对象引用注入到对象数据域中的方式来注入对方法调用的依赖。也就是实现了所谓的依赖控制反转。Bean的实例化、初始化和装配都是由Spring容器来管理 1.1 配置元数据首先，我们需要向Spring容器提供相关信息，以便于实例化Bean并指定如何对这些Bean进行装配。所提供的信息被称为配置元数据。 有三种方式来配置元数据，一是XML配置，二是基于java配置，三是基于java注解的配置，三者的区别： 具体说一下，java配置和java注解配置的不同： Java注解配置:需要在Serivce层，DAO层的时候，需要在类上进行注解，就可获得spring的依赖注入 1234567891011121314package di; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;//注解配置@Service public class UseFunctionService &#123; @Autowired FunctionService functionService; public String sayHello(String word) &#123; return functionService.toHello(word); &#125;&#125; Java配置:不需要在类上写注解了，直接在配置类里面进行申明即可 1234567891011121314package javaconfig; import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration; @Configurationpublic class JavaConfig &#123; //通过这种方式，获得spring的依赖注入 @Bean public UseFunctionService useFunctionService () &#123; return new UseFunctionService (); &#125;&#125; 1234567891011121314151617package di; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;public class UseFunctionService &#123; FunctionService functionService = new FunctionService(); public void setFunctionService(FunctionService functionService) &#123; this.functionService = functionService; &#125; public String sayHello(String word) &#123; return functionService.toHello(word); &#125;&#125; 2.依赖注入依赖注入有两种方法：Setter注入和构造函数注入。 2.1 Setter注入Setter注入是在Bean实例创建完毕之后执行。通过调用与Bean的配置元数据中定义的所有属性相对应的Setter方法注入这些属性。 具体实现：12345678//xml配置中...&lt;bean id=&quot;selfIntroductionService&quot; class=&quot;com.lanhuigu.spring.setter.SelfIntroductionServiceImpl&quot;&gt; &lt;property name=&quot;helloService&quot; ref=&quot;helloService&quot;/&gt;&lt;/bean&gt;... 12345678910111213141516171819package com.lanhuigu.spring.setter; import com.lanhuigu.spring.common.HelloService; public class SelfIntroductionServiceImpl implements SelfIntroductionService &#123; private HelloService helloService; // setter方式注入Bean public void setHelloService(HelloService helloService) &#123; this.helloService = helloService; &#125; @Override public void selfIntroduction() &#123; // 向大家打招呼 helloService.sayHello(&quot;大家好!&quot;); &#125; &#125; 2.2 构造函数注入构造函数注入在组建创建期间被执行。依赖项被表示为构造函数的参数，容器通过检查Bean定义中指定的构造函数参数来确定调用哪个构造函数。 具体实现：123456789//xml配置...&lt;bean id=&quot;accountService&quot; class=&quot;com.wiley.beginningspring.ch2.AccountServiceImpl&quot;&gt;&lt;constructor-arg ref=&quot;accountDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;com.wiley.beginningspring.ch2.AccountDaoInMemroyImpl&quot;&gt;&lt;/bean&gt;... 1234567public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; public AccountServiceImpl(AccountDao accountDao)&#123; this.accountDao = accountDao; &#125;&#125; 2.3 循环依赖构造函数注入有一个缺点，就是无法处理循环依赖。 1234567public class A&#123; private B b; public A(B b)&#123; this.b = b; &#125;&#125; 1234567public class B&#123; private A a public B(A a)&#123; this.a = a; &#125;&#125; 1234567&lt;bean id=&quot;a&quot; class=&quot;com.wiley.beginningspring.ch2.A&quot;&gt; &lt;constructor-arg ref=&quot;b&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;b&quot; class=&quot;com.wiley.beginningspring.ch2.B&quot;&gt; &lt;constructor-arg ref=&quot;a&quot;/&gt;&lt;/bean&gt; 如上就是形成了循环依赖。构造函数注入的方法是无法处理的，但Setter注入的方法能够处理此类循环，但还是不建议在配置中使用循环依赖。 2.4 依赖解析过程Spring容器的启动过程大致可分为两个主要阶段。在第一个阶段，容器处理配置元数据并建立元数据中存在的Bean定义，并对这些Bean进行验证。在该步骤中，Bean并没有被创建，相关的属性也没有被注入。在第二个阶段，首先完成Bean的创建，然后完成依赖注入。但实际上，并不是所有的Bean都被创建，在容器启动期间，仅创建了无状态作用域的Bean。 一个Bean在被完全创建且自己的依赖项被注入之前是不会作为一个依赖项被注入到其他Bean中去的。因此，必须确保被注入某一Bean中的Bean依赖项被完全配置且在目标Bean中使用。唯一的例外就是循环依赖，可以通过Setter方法来处理循环依赖，但存在缺陷，最好不要这样。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式详解]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1、什么是设计模式？首先我们来看第一个问题什么是设计模式？在百度百科中它的定义是这样的： 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。(百度百科) 其实设计模式是人们实践的产物，在初期的开发过程中好多人发现再进行重复的代码书写，那些开发大牛们就不断总结、抽取最终得到了大家的认可于是就产生了设计模式，其实设计模式的种类可以分为23种左右，今天主要和大家一起学习一下单例设计模式，因为这种设计模式是使用的最多的设计模式。在以后的文章中会给大家带来其他模式的讨论。 2、为什么会有单例设计模式？我们都知道单例模式是在开发中用的最多的一种设计模式，那么究竟为什么会有单例设计模式呢？对于这个问题相信有很多会写单例的人都会有个这个疑问。在这里先说一下单例的用途，然后举一个例子大家就会明白为什么会有单例了。单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。从其名字中我们就可以看出所谓单例，就是单个实例也就是说它可以解决的问题是：可以保证一个类在内存中的对象的唯一性，在一些常用的工具类、线程池、缓存，数据库，账户登录系统、配置文件等程序中可能只允许我们创建一个对象，一方面如果创建多个对象可能引起程序的错误，另一方面创建多个对象也造成资源的浪费。在这种基础之上单例设计模式就产生了因为使用单例能够保证整个应用中有且只有一个实例，看到这大家可能有些疑惑，没关系，我们来举一个例子，相信看完后你就会非常明白，为什么会有单例。 假如有一个有这么一个需求，有一个类A和一个类B它们共享配置文件的信息，在这个配置文件中有很多数据如下图 如上图所示现在类ConfigFile中存在共享的数据Num1，Num2，Num3等。假如在类A中修改ConfigFile中数据，在类A中应该有如下代码:12ConfigFile configFile=new ConfigFile();configFile. Num1=2; 这个时候configFile中的Num1=2，但是请注意这里是new ConfigFile是一个对象，想象一下在进行了上述操作后类B中进行如下操作：12ConfigFile configFile=new ConfigFile();System. out.println(&quot;configFile.Num1=&quot; +configFile.Num1); 即直接new ConfigFile();然后打印Num1,大家思考一下这时候打印出的数据为几？我想你应该知道它打印的结果是这样的：configFile.Num1=1;也就是说因为每次调用都创建了一个ConfigFile对象，所以导致了在类A中的修改并不会真正改变ConfigFile中的值，它所更改的只是在类A中说创建的那个对象的值。假如现在要求在类A中修改数据后，要通知类B，即在类A和类B中操作的数据是同一个数据，类A改变一个数据，类B也会得到这个数据，并在类A修改后的基础上进行操作，那么我们应该怎么做呢?看到这大家可能会说so easy,把ConfigFile中的数据设置为静态不就Ok了吗？对，有这种想法很好，这样做也没有错。但是我们都知道静态数据的生命周期是很长的，假如ConfigFile中有很多数据时，如果将其全部设成静态的，那将是对内存的极大损耗。所以全部设置成静态虽然可行但并不是一个很好的解决方法。那么我们应该怎么做呢？要想解决上面的问题，其实不难，只要能保证对象是唯一的就可以解决上面的问题，那么问题来了如何保证对象的唯一性呢？这样就需要用单例设计模式了。 3、单例模式的设计思想在上面我们说到现在解决问题的关键就是保证在应用中只有一个对象就行了，那么怎么保证只有一个对象呢？ 其实只需要三步就可以保证对象的唯一性 (1)不允许其他程序用new对象。 因为new就是开辟新的空间，在这里更改数据只是更改的所创建的对象的数据，如果可以new的话，每一次new都产生一个对象，这样肯定保证不了对象的唯一性。 (2)在该类中创建对象 因为不允许其他程序new对象，所以这里的对象需要在本类中new出来 (3)对外提供一个可以让其他程序获取该对象的方法 因为对象是在本类中创建的，所以需要提供一个方法让其它的类获取这个对象。 那么这三步怎么用代码实现呢？将上述三步转换成代码描述是这样的： (1)私有化该类的构造函数 (2)通过new在本类中创建一个本类对象 (3)定义一个公有的方法，将在该类中所创建的对象返回 4、单例模式的写法经过3中的分析我们理解了单例所解决的问题以及它的实现思想，接着来看看它的实现代码，单例模式的写法大的方面可以分为5种五种①懒汉式②饿汉式③双重校验锁④静态内部类⑤枚举。接下来我们就一起来看看这几种单例设计模式的代码实现，以及它们的优缺点。 4.1 单例模式的饿汉式[可用]12345678public class Singleton &#123; private static Singleton instance=new Singleton();private Singleton()&#123;&#125;;public static Singleton getInstance()&#123;return instance;&#125;&#125; 访问方式:Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。 优点：从它的实现中我们可以看到，这种方式的实现比较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。 缺点：由于在类加载的时候就实例化了，所以没有达到Lazy Loading(懒加载)的效果，也就是说可能我没有用到这个实例，但是它也会加载，会造成内存的浪费(但是这个浪费可以忽略，所以这种方式也是推荐使用的)。 4.2 单例模式的饿汉式变换写法[可用]1234567891011121314public class Singleton&#123; private static Singleton instance = null; static &#123;instance = new Singleton();&#125; private Singleton() &#123;&#125;; public static Singleton getInstance() &#123;return instance;&#125;&#125; 访问方式： Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。 可以看到上面的代码是按照在2中分析的那三步来实现的，这中写法被称为饿汉式，因为它在类创建的时候就已经实例化了对象。其实4.2和4.1只是写法有点不同，都是在类初始化时创建对象的，它的优缺点和4.1一样，可以归为一种写法。 4.3 单例模式的懒汉式[线程不安全，不可用]1234567891011121314public class Singleton &#123; private static Singleton instance=null; private Singleton() &#123;&#125;; public static Singleton getInstance()&#123; if(instance==null)&#123;instance=new Singleton();&#125;return instance;&#125;&#125; 这种方式是在调用getInstance方法的时候才创建对象的，所以它比较懒因此被称为懒汉式。 在上述两种写法中懒汉式其实是存在线程安全问题的，喜欢刨根问题的同学可能会问，存在怎样的线程安全问题？怎样导致这种问题的？好，我们来说一下什么情况下这种写法会有问题。在运行过程中可能存在这么一种情况：有多个线程去调用getInstance方法来获取Singleton的实例，那么就有可能发生这样一种情况当第一个线程在执行if(instance==null)这个语句时，此时instance是为null的进入语句。在还没有执行instance=new Singleton()时(此时instance是为null的)第二个线程也进入if(instance==null)这个语句，因为之前进入这个语句的线程中还没有执行instance=new Singleton()，所以它会执行instance=new Singleton()来实例化Singleton对象，因为第二个线程也进入了if语句所以它也会实例化Singleton对象。这样就导致了实例化了两个Singleton对象。所以单例模式的懒汉式是存在线程安全问题的，既然它存在问题，那么可能有解决这个问题的方法，那么究竟怎么解决呢？对这种问题可能很多人会想到加锁于是出现了下面这种写法。 4.4 懒汉式线程安全的[线程安全，效率低不推荐使用]1234567891011121314public class Singleton &#123; private static Singleton instance=null; private Singleton() &#123;&#125;; public static synchronized Singleton getInstance()&#123; if(instance==null)&#123;instance=new Singleton();&#125;return instance;&#125;&#125; 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 4.5 单例模式懒汉式[线程不安全，不可用]对于上述缺陷的改进可能有的人会想到如下的代码 12345678910111213public class Singleton7 &#123; private static Singleton instance=null; public static Singleton getInstance() &#123;if (instance == null) &#123;synchronized (Singleton.class) &#123;instance = new Singleton();&#125;&#125;return instance;&#125;&#125; 其实这种写法跟4.3一样是线程不安全的，当一个线程还没有实例化Singleton时另一个线程执行到if(instance==null)这个判断语句时就会进入if语句，虽然加了锁，但是等到第一个线程执行完instance=new Singleton()跳出这个锁时，另一个进入if语句的线程同样会实例化另外一个Singleton对象，线程不安全的原理跟4.3类似。因此这种改进方式并不可行，经过大神们一步一步的探索，写出了懒汉式的双重校验锁。 4.6 单例模式懒汉式双重校验锁[推荐用]12345678910111213141516171819public class Singleton &#123;/*** 懒汉式变种，属于懒汉式中最好的写法，保证了：延迟加载和线程安全*/private static Singleton instance=null; private Singleton() &#123;&#125;; public static Singleton getInstance()&#123;if (instance == null) &#123;synchronized (Singleton.class) &#123;if (instance == null) &#123;instance = new Singleton();&#125;&#125;&#125;return instance;&#125;&#125; 访问方式： Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。 Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (instance== null)检查，这样就可以保 证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (instance== null)，直接return实例化对象。 优点：线程安全；延迟加载；效率较高。 4.7 内部类[推荐用]12345678910111213public class Singleton&#123; private Singleton() &#123;&#125;; private static class SingletonHolder&#123;private static Singleton instance=new Singleton();&#125; public static Singleton getInstance()&#123;return SingletonHolder.instance;&#125;&#125; 访问方式： Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类，从而完成Singleton的实例化。类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，延迟加载，效率高。 4.8 枚举[极推荐使用]123456789public enum SingletonEnum &#123; instance; private SingletonEnum() &#123;&#125; public void method()&#123;&#125;&#125; 访问方式： SingletonEnum.instance.method(); 可以看到枚举的书写非常简单，访问也很简单在这里SingletonEnum.instance这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过，这种方式也是最好的一种方式，如果在开发中JDK满足要求的情况下建议使用这种方式。 5、总结在真正的项目开发中一般采用4.1、4.6、4.7、4.8看你最喜欢哪种写法了，一般情况下这几种模式是没有问题的，为了装逼我一般采用4.6这种写法，我们经常用的Android-Universal-Image-Loader这个开源项目也是采用的4.6这种写法，其实最安全的写法是4.8即枚举，它的实现非常简单而且最安全可谓很完美，但是可能是因为只支持JDK1.5吧又或者是因为枚举大家不熟悉所以目前使用的人并不多，但是大家可以尝试下。另外当我们使用反射机制时可能不能保证实例的唯一性，但是枚举始终可以保证唯一性，具体请参考次博客：http://blog.csdn.net/java2000_net/article/details/3983958但是一般情况下很少遇到这种情况。 6、单例模式的在面试中的问题单例模式在面试中会常常的被遇到，因为它是考查一个程序员的基础的扎实程度的，如果说你跟面试官说你做过项目，面试官让你写几个单例设计模式，你写不出来，你觉着面试官会相信吗？在面试时一定要认真准备每一次面试，靠忽悠即使你被录取了，你也很有可能会对这个公司不满意，好了我们言归正传，其实单例设计模式在面试中很少有人会问饿汉式写法，一般都会问单例设计模式的懒汉式的线程安全问题，所以大家一定要充分理解单例模式的线程安全的问题，就这几种模式花点时间，认真学透，面试中遇到任何关于单例模式的问题你都不会害怕是吧。 7、 说明上述文章均引用自：https://blog.csdn.net/q_all_is_well/article/details/82377917 ，感觉写的很不错，就拿来用了。]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock的使用]]></title>
    <url>%2F2019%2F05%2F05%2FLock%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在Java多线程中，可以使用synchronized关键字来实现线程之间的同步互斥，但在JDK1.5后新增了ReetrantLock类也能达到同样的效果，并且在扩展功能上也更加强大。 1.ReentrantLock类的使用1.1 简单使用 ReentrantLock1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.locks.ReentrantLock;/** * Created by haicheng.lhc on 17/05/2017. * * @author haicheng.lhc * @date 2017/05/17 */public class ReentrantLockTest extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); public static int i = 0; public ReentrantLockTest(String name) &#123; super.setName(name); &#125; @Override public void run() &#123; for (int j = 0; j &lt; 10000000; j++) &#123; lock.lock(); try &#123; System.out.println(this.getName() + &quot; &quot; + i); i++; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; /** * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; ReentrantLockTest test1 = new ReentrantLockTest(&quot;thread1&quot;); ReentrantLockTest test2 = new ReentrantLockTest(&quot;thread2&quot;); test1.start(); test2.start(); test1.join(); test2.join(); System.out.println(i); &#125; 最后的结果是 20000000；如果去掉锁，那么输出结果是一个小于20000000的不确定的数。 1.2 使用Conditon实现等待/通知12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.jalja.org.base.Thread;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * Condition 配合Lock 实现线程的等待 与通知 */public class ConditionTest&#123; public static ReentrantLock lock=new ReentrantLock(); public static Condition condition =lock.newCondition(); public static void main(String[] args) &#123; new Thread()&#123; @Override public void run() &#123; lock.lock();//请求锁 try&#123; System.out.println(Thread.currentThread().getName()+&quot;==》进入等待&quot;); condition.await();//设置当前线程进入等待 &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock();//释放锁 &#125; System.out.println(Thread.currentThread().getName()+&quot;==》继续执行&quot;); &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; lock.lock();//请求锁 try&#123; System.out.println(Thread.currentThread().getName()+&quot;=》进入&quot;); Thread.sleep(2000);//休息2秒 condition.signal();//随机唤醒等待队列中的一个线程 System.out.println(Thread.currentThread().getName()+&quot;休息结束&quot;); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock();//释放锁 &#125; &#125; &#125;.start(); &#125;&#125; 需要注意，在调用condition.await()和condition.signal()之前必须先调用lock.lock()代码，获得同步监视器，也就是先要获得锁。 1.3 使用多个Condition实现通知部分线程新建MyService.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package service; importjava.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;importjava.util.concurrent.locks.ReentrantLock; public class MyService &#123; privateLock lock = new ReentrantLock(); publicCondition conditionA = lock.newCondition(); publicCondition conditionB = lock.newCondition(); publicvoid awaitA() &#123; try&#123; lock.lock(); System.out.println(&quot;beginawaitA时间为&quot; +System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionA.await(); System.out.println(&quot; end awaitA时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; publicvoid awaitB() &#123; try&#123; lock.lock(); System.out.println(&quot;beginawaitB时间为&quot; +System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionB.await(); System.out.println(&quot; end awaitB时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; publicvoid signalAll_A() &#123; try&#123; lock.lock(); System.out.println(&quot; signalAll_A时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionA.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125; publicvoid signalAll_B() &#123; try&#123; lock.lock(); System.out.println(&quot; signalAll_B时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionB.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125; 新建ThreadA.java :1234567891011121314151617181920212223242526272829303132333435package extthread; import service.MyService; public class ThreadA extends Thread &#123; privateMyService service; publicThreadA(MyService service) &#123; super(); this.service= service; &#125; @Override publicvoid run() &#123; service.awaitA(); &#125;&#125; 新建ThreadB.java :1234567891011121314151617181920212223242526272829303132333435package extthread; import service.MyService; public class ThreadB extends Thread &#123; privateMyService service; publicThreadB(MyService service) &#123; super(); this.service= service; &#125; @Override publicvoid run() &#123; service.awaitB(); &#125;&#125; 新建Run.java :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package test; import service.MyService;import extthread.ThreadA;import extthread.ThreadB; public class Run &#123; publicstatic void main(String[] args) throws InterruptedException &#123; MyServiceservice = new MyService(); ThreadAa = new ThreadA(service); a.setName(&quot;A&quot;); a.start(); ThreadBb = new ThreadB(service); b.setName(&quot;B&quot;); b.start(); Thread.sleep(3000); service.signalAll_A(); &#125;&#125; 运行结果，只有线程A被唤醒了。 1.4 公平锁和非公平锁锁Lock分为公平锁和非公平锁。公平锁表示线程获取锁的顺便是按照线程加锁的顺序来分配的，即先来先得，先进先出的顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的。公平锁的顺序是大体如此，并不是100%。在默认情况下，ReentrantLock类使用的是非公平锁。 1.5 使用Conditon可实现顺序执行2.ReentrantReadWriteLock类的使用ReentrantReadWriteLock类表示有两种锁，一个是读操作相关的锁，也称共享锁；另一个是写操作相关的锁，也叫排他锁。写锁与写锁互斥，写锁与读锁互斥，读锁与读锁不互斥。 读锁是长这样的：123456.....private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();.....lock.readLock().lock().....lock.readLock().unlock() 写锁长这样：123456.....private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();.....lock.writeLock().lock().....lock.writeLock().unlock() 使用方法和普通的Lock类似，只要记得写锁与写锁互斥，写锁与读锁互斥，读锁与读锁不互斥。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程间通信]]></title>
    <url>%2F2019%2F05%2F05%2F%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1.使用wait/notify实现线程间的通信1.1 等待/通知机制的实现方法wait()的作用是使当前执行代码的线程进行等待。在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步代码块中调用wait()方法。在执行wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。方法notify()也要在同步方法或同步代码块中调用。该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则按优先级来获取，否则随机挑选一个呈wait状态的线程，对其发出通知notify，并使它进入就绪队列，也叫锁池。另外需要说明的是，在执行notify()方法之后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程将程序执行完，也就是推出synchronized代码块后，当前线程才会释放锁，然后由就绪队列里的线程争夺锁。当一个获得了该对象的wait()线程运行完毕后，会释放该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。 1.2 方法wait(long)的使用带一个参数的的wait(long)方法的功能是等待某一时间内是否有线程对锁唤醒，如果超过这个时间则自动唤醒。 1.3 等待wait的条件发生变化如果采用if判断，当线程从wait中唤醒时，那么将直接执行处理其他业务逻辑的代码，但这时候可能出现另外一种可能，条件谓词已经不满足处理业务逻辑的条件了，从而出现错误的结果，于是有必要进行再一次判断，所有一般wait()方法是在while循环里，这样便于检测wait的条件是否变化。 2.生产者/消费者模式的实现2.1 线程假死现象“假死”现象其实就是线程全部进入WAITING等待状态，这时，程序不再执行任何业务功能，整个项目呈停止状态。“假死”出现的原因是notify唤醒的时候，也许是异类，也许是同类，比如生产者唤醒生产者，或消费者唤醒消费者这样的情况。如果按这样运行的比率积少成多，最终就会导致所有的线程都不能继续运行下去，大家都在等待，都呈WAITING状态，就是”假死”。 3.方法join的使用方法join()的作用是使所属的线程对象X正常执行run()方法中的任务，而使当前线程Z进行无限期的阻塞，等待线程X销毁后再继续执行线程Z后面的代码。 3.1 join与synchronized的区别方法join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait()方法进行等待，而sychroized该关键字使用的是”对象监视器”原理做为同步。 3.2 方法join(long)与sleep(long)的区别join(long)的功能在内部是使用wait(long)方法实现的，所以join(long)方法具有释放锁的特点。而Thread.sleep(long)方法却不释放锁。 4.ThreadLocal的使用ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 4.1 ThreadLocal的内部结构图 从上面的结构图，我们已经窥见ThreadLocal的核心机制： 每个Thread线程内部都有一个Map。Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 4.2 ThreadLocal与InheritableThreadLocal的区别ThreadLocal和InheritableThreadLocal本质上只是为了方便编码给的工具类，具体存数据是ThreadLocalMap 对象。ThreadLocalMap 存的key对象是ThreadLocal，value就是真正需要存的业务对象。Thread里通过两个变量持用ThreadLocalMap 对象，分别为：threadLocals和inheritableThreadLocals。InheritableThreadLocal之所以能够完成线程间变量的传递，是在new Thread()的时候对inheritableThreadLocals对像里的值进行了复制。子线程通过继承得到的InheritableThreadLocal里的值与父线程里的InheritableThreadLocal的值具有相同的引用，如果父子线程想实现不影响各自的对象，可以重写InheritableThreadLocal的childValue方法。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2F2019%2F05%2F03%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[关键字volatile的主要作用是使变量在多个线程间可见。具体来说就是，volatile关键字，可以强制的从公共内存中读取变量的值，这样就不会因为私有堆栈中的值和公共堆栈中的值不同步而导致错误。 1.volatile 和 synchronized 的比较1) volatile只能修饰于变量，而 synchronized可以修饰方法，以及代码块。2) 多线程访问 volatile不会发生阻塞，而 synchronized会出现阻塞。3) volatile能保证数据的可见性，但不能保证原子性。 synchronized两者都可以保证。4) volatile解决的是变量在多个线程之间的可见性，而 synchronized解决的是多个线程之间访问资源的同步性。 2. i++操作时的非线程安全问题表达式i++的操作步骤分解如下： 1)从内存中取出i的值2)计算i的值3)将i的值写到内存中 假如在第二步计算值的时候，另外一个线程也修改i的值，这时候就会出现脏数据。解决方法就是使用 synchronized关键字。 3.synchronized有和volatile一样的功能synchronized不仅可以保证同步，还可以保证可见性。在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>volatile关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized同步语句块]]></title>
    <url>%2F2019%2F05%2F02%2Fsynchronized%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97%2F</url>
    <content type="text"><![CDATA[用关键字 synchronized 来声明方法在某些情况下是有弊端的，比如A线程调用了同步方法执行一个长时间的任务，那么B线程则必须等待比较长的时间。在这种情况下可以使用 synchronized同步语句块 来解决。 synchronized方法 是对当前对象加锁，而 synchronized同步语句块 是对某一个对象加锁。 1.用同步代码块解决同步方法的弊端同步方法的弊端上面说过了，就是效率慢。为什么同步代码块就能解决？因为当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中的非 synchronized(this) 同步代码块。 2.synchronized代码块间的同步性当一个线程访问object的 synchronized(this)同步代码块时，其他线程对同一个object中所有其他 synchronized(this)同步代码块的访问将被阻塞，这说明 synchronized 使用的对象监视器是一个。但可以异步访问 synchronized(其他对象) 的语句块。因为这时候他们的对象监视器就不是同一个了。 3.synchronized锁定的是当前对象synchronized(this)代码块锁定的是当前对象，和 synchronized方法是一样的。这就意味着，他们的对象监视器是同一个，会发生排斥。也就是说，当A线程在访问object的 synchronized(this)同步代码块的时候，那么B线程这时候访问object中的 synchronized方法就会受阻，必须等A线程访问结束，释放了锁后,B线程才能访问。因为他们持有的是同一个锁，都是锁定的当前对象。同一个object里的 synchronized(anthing) 和 synchronized(this) 是不互斥的，可以异步执行。同一个object里的 synchronized(anthing) 和 synchronized方法 是不互斥的，可以异步执行。同一个object里的 synchronized方法 和 synchronized(this) 是互斥的，必须同步执行。 4.synchronized(非this对象x)的三个结论“synchronized(非this对象x)”格式的写法是将x对象本身作为”对象监视器” 1)当多个线程同时执行 synchronized(x){}同步代码块时呈同步效果。2)当其他线程执行x对象中 synchronized同步方法时呈同步效果。3)当其他线程执行x对象方法里面的 synchronized(this)代码块时也呈同步效果。注意：如果其他线程调用的是不加 synchronized 关键字的方法时，还是异步调用 5.静态同步 synchronized方法与 synchronized(class)代码块synchronized关键字还可以用在 static静态方法上，这样写的话，就是对当前.java文件对应的Class类持锁。和 synchronized关键字加到非static静态方法不一样，这个是给对象上锁。 1)当A线程执行object里的 synchronized修饰的 static静态方法时，那么其他线程不能同时执行该object里用 synchronized修饰的static静态方法。属于互斥状态。1)当A线程执行object里的 synchronized修饰的 static静态方法时，其他线程可以执行该object里用 synchronized修饰的非static静态方法。不属于互斥状态，因为不是同一把锁。3)同步synchronized(xx.class)作用和 synchronized static 方法的作用一样。 synchronized static 方法需是xx.class里的。 6.数据类型String的常量池特性在jvm中具有String常量池缓存的功能。简单来说，就是我输一次A，如果String常量池没有A，那么这个A就会被保存在String常量池里。当我要用A时，这时就会把String常量池里的A指向变量。所有的A都是同一个。如果把A当作锁，那么便会出现相同的锁，就会出现问题。 7.锁对象的改变如果锁对象的值中途改变，那么锁也就会改变，马上会由同步变为异步。需要注意的是：只要对象不变，即使对象的属性被改变，运行的结果还是同步。比如对象是USER这个类，运行过程中，改变了USER里的一个属性name的值，但对象还是没变，还是会同步执行下去。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized同步方法]]></title>
    <url>%2F2019%2F04%2F29%2Fsynchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[”非线程安全“会在多个线程对同一个对象中的实例对象进行并发访问时发生，产生的后果就是”脏读“，也就是取到的数据其实是被更改过的。而”线程安全“就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。 #1.方法内的变量为线程安全 方法中的变量不存在非线程安全问题，这是方法内部的变量是私有的特性造成的。 #2.实例变量非线程安全 如果多个线程共同访问1个对象中的实例变量，需要在方法前添加关键字 synchronized 。这样就不会出现非线程安全问题。 #3.多个对象多个锁 123456Hbbq h1 = new Hbbq();Hbbq h2 = new Hbbq();Thread athread = new Thread(h1);athread.start();Thread bthread = new Thread(h2);bthread.start(); 从以上代码可以看出，我们创建了两个 Hbbq 的实例对象。这样的话，加了 synchronized 的方法，便会产生两个锁，结果就不会是同步，而是以异步的方式运行的。如果多个线程访问多个对象，JVM就会创建多个锁，就像上面的示例一样。同步的单词是 synchronized ，异步的单词是 asynchronized。 #4.synchronized方法与锁对象 当两个线程同时访问一个对象的不同的两个方法：第一次实验的是一个同步的方法，一个不同步的方法第二次实验的是两个都是同步的方法 代码我就不贴了，直接写结论：1）A线程先持有object对象的lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。2）A线程先持有object对象的lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需等待，也就是同步。 #5.脏读 出现脏读的原因就是不同步。解决的方法就是加上同步synchronized关键字。这里注意一点，当一个线程A调用了对象里加入synchronized关键字的X方法时，那么A线程就获得了X的方法锁，更准确的讲，是获得了这个对象的锁，其他线程必须等待A线程执行完毕才可以调用X方法，但其他线程可以随意调用其他的非synchronized同步方法。所以，需要把set 和 get 方法都加上 synchronized 关键字，这样的话就可以避免出现脏读。 #6.synchronized锁重入 可重入锁的概念是：自己可以再次获取自己的内部锁。这样就可以调用 synchronized方法 里的 synchronized方法。可重入锁也支持在父子类继承的环境中。在子类中调用父类里的变量，值也可以同步。 #7.出现异常，锁自动释放 就是说，当一个线程执行的代码出现异常时，那么这个线程所持有的锁会被自动释放，然后别的线程就可以继续去调用这个方法了。 #8.同步不具有继承性 当一个子类继承一个父类时，子类重写父类的 synchronized 方法，却没有加关键字 synchronized，这样就会造成非线程安全(异步)。由此可以看出，同步不能继承。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[有三种方式来停止线程：1. 正常执行 run()方法，run()方法结束后，线程终止。2. 使用 stop 方法强行终止线程，不推荐使用，会造成不可预料的后果。3. 使用 interrupt 方法中断线程。 现在对于第三种方式来详细了解一下。在Java的SDK中，Thread.java类提供了两种方法：1) this.interrupted()：测试当前线程是否已经中断。2) this.isinterrupted()：测试线程是否已经中断。interrupted()是静态方法，所以我们用Thread.interrupted()方法表示，它调用的是currentThread().isInterrupted(true)方法，即说明是返回当前线程的是否已经中断的状态值，而且有清理中断状态的机制。而isInterrupted()是一个实例方法，所以我们用this.isInterrupted()方法表示，它调用的是isInterrupted(false)方法，意思是返回线程是否已经中断的状态值，与Thread.interrupted()方法相反，它没有清理中断状态的机制。 二者的区别在于：interrupted()是static方法，调用的时候要用Thread.interrupted()，而isInterrupted()是实例方法，调用时要用线程的实例调用；Thread.interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能；this.isInterrupted()：测试线程Thread对象是否已经是中断状态，但不清除状态标志。 线程的停止——抛异常法1234567891011121314151617181920public class MyThread4 extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 50000; i++) &#123; if (this.isInterrupted()) &#123; System.out.println( &quot;线程已经结束，我要退出&quot; );// return; //这是return法停止线程 throw new InterruptedException(); //抛异常法停止线程 &#125; System.out.println( &quot;i=&quot; + (i + 1) ); &#125; System.out.println( &quot;我是for下面的语句，我被执行说明线程没有真正结束&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;进入MyThread.java类中run方法的catch异常了&quot; ); e.printStackTrace(); &#125; &#125;&#125; 1234567891011public static void main(String[] args) &#123; try &#123; MyThread4 myThread4 = new MyThread4(); myThread4.start(); Thread.sleep( 20); myThread4.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 推荐使用抛异常法。 线程的停止——在沉睡中停止这个名字非常好听，让我们看下具体是怎么实现的。12345678910111213141516171819202122public void run() &#123; super.run(); try &#123; System.out.println( &quot;begin run&quot; ); Thread.sleep( 500 ); System.out.println( &quot;begin end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;在沉睡中终止&quot;); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); Thread.sleep( 20 ); thread5.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 其实就是在执行中断操作前，执行一个sleep()方法。那为什么这样就能停止线程呢？看这句话：当线程处于下面的状况时（（1）如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个InterruptedException异常。这个时候，我们可以通过捕获InterruptedException异常来终止线程的执行，具体可以通过return等退出或改变共享变量的值使其退出。）这样看来，其实这两个方法都属于抛异常法，一个是主动抛出异常，一个是调用sleep()后，被系统抛出异常。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识多线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[开始系统地来学习多线程。采用边学变记录的方式。不想耽误太多时间来码字，所以我打算写的随意一点，以自己能看懂为目的，来记录一些需要记住的知识，便于日后的复习，虽然也可能根本不复习，但是记录还是有用的，至少能让后我现在加深一次记忆。 1. 进程，线程1.1 进程运行在内存中的exe程序，就是进程。就像任务管理器里看到的exe程序，都是正在运行的进程。 1.2 线程线程可以理解为，在进程中独立运行的子任务。打个比方，QQ.exe运行时就有很多子任务在同时运行，比如好友视频线程，下载文件线程，发送表情线程等等。这些不同的任务都能同时进行，这些子任务都可以理解为线程在工作。 1.3 线程的优点使用多线程，可以在同一时间同时运行不同种类的任务。通过一个图可以清楚的看到优点所在。使用多线程，任务2便不用等到任务1运行完才能运行。这是就是多线程的优点，使用多线程也就是在使用异步。 2. 使用多线程有两种方法来实现多线程，一种是继承Thread类，一种是实现Runnable接口。因为Java不支持多继承，一个子类只能有一个父类。所以当想创建的线程类已经有一个父类时，就不能再继承Thread类了，这时需要通过实现Runnable类来实现多线程。注意：启动多线程，必须使用thread.start()方法，且类里的方法名必须为run()，开启start()方法后，run()方法会被自动调用。另外还需要知道，执行start()方法的顺序不代表线程启动的顺序，顺序是随机的。 2.1 非线程安全问题指的是多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。解决方法是在方法前加 synchronized 关键字。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识IO]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%A4%E8%AF%86IO%2F</url>
    <content type="text"><![CDATA[大多数应用程序都需要实现与设备之间的数据传输。在Java中，将通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象描述为”流”。Java中的流都位于 java.io 包中，称为IO(输入输出)流。 1.字节流1.1 字节流的概念在计算机中，无论是文本、图片、音频还是视频，所有的文件都是以二进制(字节)形式存在的。IO流中针对字节的输入输出提供了一系列的流，统称为字节流。在JDK中，提供了两个抽象类 InputStream 和 OutputStream ,他们是字节流的顶级父类，所有的字节输入流都继承自 InputStream ，所有的字节输出流都继承自 OutputStream 。 1.2 字节流读写文件针对文件的独写，JDK专门提供了两个类，分别是 FileInputStream 和 FileOutputStream 。FileInputStream 是 InputStream 的子类，它是操作文件的字节输入流，专门用于读取文件中的数据。FileOutputStream 是 OutputStream 的子类，它是操作文件的字节输出流，专门用于把数据写入文件。 1.3 字节流的缓冲区主要代码：12345byte[] buff = new byte[1024];int len;while((len=in.read(buff))!=-1)&#123;out.write(buff,0,len)&#125; 上述代码实现了用缓冲区来拷贝文件。首先定义了一个字节数组，作为缓冲区。字节数组被填满后，执行写入，把字节数组里的内容全部写入。最后输出流关闭时，也会执行写入，可以防止数组里没有写满的没有写入文件。 1.4 字节缓冲流在IO包中提供两个带缓冲的字节流，分别是 BufferedInputStream 和 BufferedOutputStream 。简单理解就是，自带了缓冲区的字节流。使用方法，把类包装起来。主要代码如下：BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;src.txt&quot;));就这样包起来，所以也叫包装流。 2.字符流InputStream 类和 OutputStream 类在读写文件时操作的都是字节。同样，JDK也提供了字符流，用来操作字符。Reader 和 Writer 分别是两个抽象的顶级父类。Reader是字符输入流，用与读取字符。Writer是字符输出流，用于写入字符。 2.1 字符流操作文件FileReader 是 Reader 的子类，可以读取一个或一组字符。FileWriter 是 Writer 的子类，用于写入字符。同字节缓冲流一样，字符也有字符缓冲流 BufferedReader 和 BufferedWriter 。操作方法也一样。需要注意的是，BufferedWriter 中的一个重要方法 readLine()，和 FileOutputStream 里的 read()，用法一样，区别是read()一次读取一个字节，而readLine()一次读取一行字符。需要注意。 2.2 转换流字节流和字符流之间可以互相转换。利用 InputStreamReader 和 OutputStreamWriter 这两个类进行转换。转换流其实也是一种包装流，其中 OutputStreamWriter 是 Writer 的子类,InputStreamReader 是 Reader 的子类。用的时候包装一下就可以了，和上面两个缓冲流用法一样。 3.其他流3.1 ObjectInputStream 和 ObjectOutputStream程序运行时，会创建对象，程序结束后，这些对象会被垃圾回收。如果希望永久保存这些对象，则可以将对象转为字节数据写入硬盘，这个过程叫对象序列化。JDK提供了 ObjectOutputStream 来实现序列化, ObjectInputStream 用来反序列化。当对象序列化时，必须保证对象实现了Serializable接口，否则程序会报错。]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件装载流程]]></title>
    <url>%2F2019%2F04%2F15%2Fclass%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.装载流程图class文件的装载流程如图所示。 2.类装载的条件首先我们要搞清楚，class只有在必须要使用时才会被装载。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：· 当创建一个类的实例时，比如使用new关键字，或者通过反射，克隆，反序列化· 当调用类的静态方法，即当使用了字节码 invokestatic 指令· 当使用类或接口的静态字段时（final常量除外），比如，使用 getstatic 或者 putstatic 指令· 当使用 java.lang.refect 包中的方法反射类的方法时· 当初始化子类时，要求先初始化父类· 作为启动虚拟机，含有main()方法的那个类 3.流程分析3.1 加载类加载类处于类装载的第一个阶段。在加载类时，java虚拟机必须完成以下工作:· 通过类的全名，获取类的二进制数据流· 解析类的二进制数据流为方法区内的数据结构· 创建java.lang.Class 类的实例，表示该类型 对于类的二进制流数据，虚拟机可以通过多种途径产生和获得。最一般地是通过文件系统读入一个class文件。在获取类的二进制信息后，Java虚拟机就会处理这些数据，并最终转化为一个java.lang.Class的实例，java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据。通过class类提供的接口，可以访问一个类的方法，字段等信息。 3.2 连接连接可以分为三个步骤：验证，准备，解析。 3.2.1 验证类当类加载到系统后，就开始连接操作，验证是连接操作的第一步。大体上Java虚拟机需要做以下的检查：检查的内容如图所示，比较详细，我就不一一说明了。 3.2.2 准备当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置初始值。如果类中存在常量字段，那么常量字段也会在准备阶段被附上正确的值，这个赋值属于Java虚拟机的行为，属于变量的初始化。在这个阶段，不会有任何Java代码被执行。 3.2.3 解析类在准备阶段完成后，就进入到了解析阶段。解析阶段的工作就是将类、接口、字段和方法的符号引用转为直接引用。Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。这就是解析阶段的工作，将类、接口、字段和方法的符号引用转为直接引用。 3.3 初始化类的初始化是类装载的最后一个阶段。此时，类才会开始执行Java字节码。主要工作是执行类的初始化方法 。方法是由编译器自动生成的，它是由类静态成员的赋值语句以及 static 语句结合产生的。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>class文件装载流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笑忘录]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%AC%91%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[人与政权的斗争，就是记忆与遗忘的斗争。 —米兰昆德拉 今天下午看到了一些东西。这些东西颠覆了我的认知。让我感到无奈，无力，压抑。 我很难受，但是却没法和人说。我深知互联网不是可以畅所欲言的地方。 在这一点上，他们是成功的。身边也无人可说，因为很多人都不知道，至少我身边的人应该是不知道。在这一点上，他们也是成功的。 但这样是不对的，不应该以这样的方式来对待。我们不应该忘记，我们也不能忘记，我们需要一个说法。 我避免了很多的敏感词汇，这样的叙述让我很难受，丝毫表达不出我所想。但我又很怂，我不知道写在这里有没有事。在一点上，我更加敬佩那些能够勇于发声的人。这样的人，最终都不会有什么好的结果。但这样的人，才是真正伟大的人。 写出来这些话，我认为这样能让我舒服一点，但是好像没什么用。了解了更多，只会觉得我们更加可悲。似乎理解了一些人，也感觉自己之前的思想很可笑，无知。 我希望她能够等到那一天的到来，如果不行，我希望我可以等到那一天的到来。如果还不行，至少希望自己到时不要已经变成一个麻木不堪，对什么都不在意的人。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo插入图片]]></title>
    <url>%2F2019%2F04%2F14%2Fpictest%2F</url>
    <content type="text"><![CDATA[1.更改 _config.yml 配置文件首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.安装插件到博客的根目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save命令来进行插件的安装，用于加载本地文件。 3.创建文章执行 hexo new page pictest 创建文章。执行后我们会发现，这次创建 pictest.md 文章的同时，还会多出来一个 pictest 的文件夹。我们可以把文章里所用到的静态资源都放在这里，然后在文章里进行引用。 4.引用方式![图片别名随便写](pictest/图片名称.jpg) 5.引用我们来引用一张图片试一下 6.部署三连hexo cleanhexo ghexo d 7.打开浏览器查看是否成功]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法初试]]></title>
    <url>%2F2019%2F04%2F12%2FMarkdown%E8%AF%AD%E6%B3%95%E5%88%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.标题测试1.1不错 1.2还可以吧 1.3应该行 2.链接测试2.1 普通链接这是我的微博这是我的简书代码：[这是我的微博](https://weibo.com/u/6059487421?is_hot=1/)[这是我的简书](https://www.jianshu.com/u/21a1a8bdb771/) 2.2 自动链接这是我的微博：https://weibo.com/u/6059487421?is_hot=1这是我的简书：https://www.jianshu.com/u/21a1a8bdb771 3.代码测试3.1 行内代码system.out.println(&quot;你好！&quot;) 3.2 多行代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.hfbin.sync003;/** * 对象锁的同步和异步问题 * @author cn.hfbin * */public class MyObject &#123; public synchronized void method1()&#123; try &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** synchronized */ public void method2()&#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject mo = new MyObject(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method1(); &#125; &#125;,&quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method2(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; 4.引用测试 我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。表示尽管自己惯于冷眼看待军阀政府的文过饰非，从最坏最恶毒的方面去推测他们可能的做法，仍然料不到他们竟然凶残到超出自己的想象。 ​]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号大记]]></title>
    <url>%2F2019%2F04%2F10%2FsecondBlog%2F</url>
    <content type="text"><![CDATA[待会有课夜里也有课今天跑不成步了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号小记]]></title>
    <url>%2F2019%2F04%2F10%2Fnewpapername%2F</url>
    <content type="text"><![CDATA[今天有点冷，还可以吧。运动会，可以买水了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
</search>
