<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring事务管理]]></title>
    <url>%2F2019%2F05%2F13%2FSpring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Spring管理的Bean]]></title>
    <url>%2F2019%2F05%2F13%2FSpring%E7%AE%A1%E7%90%86%E7%9A%84Bean%2F</url>
    <content type="text"><![CDATA[被Spring创建和管理的Java对象被称为Bean。这些对象都是POJO，但却在Spring容器中被管理。因此，也常把她们称为Spring管理的Bean。 1.命名BeanBean通过名称进行区分。每一个Bean至少有一个名称。如果没有给它命名，Spring容器将会为它分配一个内部名称。通过Bean的名称，可以从其他的Bean定义中或者用显示查找从应用程序代码中引用Bean。在基于XML的配置中，使用id属性将一个名称分配给Bean。在同一个XML文件中，不能复制同一个名称。然而，在其他XML文件中，可以将相同的名称分配给另一个Bean定义。这时，Bean重写机制开始发挥作用。 1&lt;bean name=&quot;accountDao,A,B&quot; class=&quot;com.mzh.test&quot;/&gt; 或者 123&lt;bean id=&quot;accountDao&quot; class=&quot;com.mzh.test&quot;/&gt;&lt;alias name=&quot;A&quot; alias=&quot;accountDao&quot;/&gt;&lt;alias name=&quot;B&quot; alias=&quot;accountDao&quot;/&gt; 2.Bean实例化方法一：调用相关类中一个可用的构造函数 二：调用可用的静态或实例工厂方法。 三：使用Spring自带的FactoryBean接口。 3.Bean作用域由Spring容器创建的Bean的生存期被称为Bean作用域。默认情况下，由Spring容器创建的所有Bean都是Singleton作用域。换句话说，针对一个Bean定义只创建了一个Bean实例，并且Spring容器可以在整个应用程序中使用该实例。当不同的Bean与不同的层（控制层、服务层和数据访问层）相对应时，可以使用Singleton作用域。此时创建的实例都是无状态实例，在同一时间服务于不同的请求。 Spring 3中为Bean定义了5中作用域，分别为singleton（单例）、prototype（原型）、request、session和global session，5种作用域说明如下： singleton: 单例模式，Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。Singleton作用域是Spring中的缺省作用域，也可以显示的将Bean定义为singleton模式，配置为：1&lt;bean id=&quot;userDao&quot; class=&quot;com.ioc.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt; prototype: 原型模式，每次通过Spring容器获取prototype定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。 request： 在一次Http请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效。1&lt;bean id=&quot;loginAction&quot; class=&quot;com.cnblogs.Login&quot; scope=&quot;request&quot;/&gt;,针对每一次Http请求，Spring容器根据该bean的定义创建一个全新的实例，且该实例仅在当前Http请求内有效，而其它请求无法看到当前请求中状态的变化，当当前Http请求结束，该bean实例也将会被销毁。 session: 在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。1&lt;bean id=&quot;userPreference&quot; class=&quot;com.ioc.UserPreference&quot; scope=&quot;session&quot;/&gt;,同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。 global Session： 在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。 4.延迟初始化默认情况下，Spring容器在启动阶段创建Bean。该过程被称为预先Bean初始化。其优点是可以尽早发生配置错误。例如，在基于XML的配置中，Bean定义的类属性出现了错别字，或者引用了一个不可用的Bean定义等。但另一方面，如果存在大量的Bean定义或者一些特殊的Bean，那么初始化可能会降低启动速度。 如果将Bean配置为延迟创建，那么容器将会延迟Bean的创建，直到真正需要时才创建。通过从一个已经创建的另一个Bean中的引用，或者在应用程序代码中执行显示Bean查找，都可以触发Bean的创建。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring管理的Bean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用spring进行依赖注入]]></title>
    <url>%2F2019%2F05%2F13%2F%E4%BD%BF%E7%94%A8spring%E8%BF%9B%E8%A1%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1.Spring IoC容器在这里，我们先不具体深入的了解Spring IoC容器，只需要知道它是做什么的。Spring的核心就是IoC容器，它的作用是可以在对象生成或初始化时直接将数据注入到对象中，也可以通过将对象引用注入到对象数据域中的方式来注入对方法调用的依赖。也就是实现了所谓的依赖控制反转。Bean的实例化、初始化和装配都是由Spring容器来管理 1.1 配置元数据首先，我们需要向Spring容器提供相关信息，以便于实例化Bean并指定如何对这些Bean进行装配。所提供的信息被称为配置元数据。 有三种方式来配置元数据，一是XML配置，二是基于java配置，三是基于java注解的配置，三者的区别： 具体说一下，java配置和java注解配置的不同： Java注解配置:需要在Serivce层，DAO层的时候，需要在类上进行注解，就可获得spring的依赖注入 1234567891011121314package di; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;//注解配置@Service public class UseFunctionService &#123; @Autowired FunctionService functionService; public String sayHello(String word) &#123; return functionService.toHello(word); &#125;&#125; Java配置:不需要在类上写注解了，直接在配置类里面进行申明即可 1234567891011121314package javaconfig; import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration; @Configurationpublic class JavaConfig &#123; //通过这种方式，获得spring的依赖注入 @Bean public UseFunctionService useFunctionService () &#123; return new UseFunctionService (); &#125;&#125; 1234567891011121314151617package di; import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;public class UseFunctionService &#123; FunctionService functionService = new FunctionService(); public void setFunctionService(FunctionService functionService) &#123; this.functionService = functionService; &#125; public String sayHello(String word) &#123; return functionService.toHello(word); &#125;&#125; 2.依赖注入依赖注入有两种方法：Setter注入和构造函数注入。 2.1 Setter注入Setter注入是在Bean实例创建完毕之后执行。通过调用与Bean的配置元数据中定义的所有属性相对应的Setter方法注入这些属性。 具体实现：12345678//xml配置中...&lt;bean id=&quot;selfIntroductionService&quot; class=&quot;com.lanhuigu.spring.setter.SelfIntroductionServiceImpl&quot;&gt; &lt;property name=&quot;helloService&quot; ref=&quot;helloService&quot;/&gt;&lt;/bean&gt;... 12345678910111213141516171819package com.lanhuigu.spring.setter; import com.lanhuigu.spring.common.HelloService; public class SelfIntroductionServiceImpl implements SelfIntroductionService &#123; private HelloService helloService; // setter方式注入Bean public void setHelloService(HelloService helloService) &#123; this.helloService = helloService; &#125; @Override public void selfIntroduction() &#123; // 向大家打招呼 helloService.sayHello(&quot;大家好!&quot;); &#125; &#125; 2.2 构造函数注入构造函数注入在组建创建期间被执行。依赖项被表示为构造函数的参数，容器通过检查Bean定义中指定的构造函数参数来确定调用哪个构造函数。 具体实现：123456789//xml配置...&lt;bean id=&quot;accountService&quot; class=&quot;com.wiley.beginningspring.ch2.AccountServiceImpl&quot;&gt;&lt;constructor-arg ref=&quot;accountDao&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;accountDao&quot; class=&quot;com.wiley.beginningspring.ch2.AccountDaoInMemroyImpl&quot;&gt;&lt;/bean&gt;... 1234567public class AccountServiceImpl implements AccountService&#123; private AccountDao accountDao; public AccountServiceImpl(AccountDao accountDao)&#123; this.accountDao = accountDao; &#125;&#125; 2.3 循环依赖构造函数注入有一个缺点，就是无法处理循环依赖。 1234567public class A&#123; private B b; public A(B b)&#123; this.b = b; &#125;&#125; 1234567public class B&#123; private A a public B(A a)&#123; this.a = a; &#125;&#125; 1234567&lt;bean id=&quot;a&quot; class=&quot;com.wiley.beginningspring.ch2.A&quot;&gt; &lt;constructor-arg ref=&quot;b&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;b&quot; class=&quot;com.wiley.beginningspring.ch2.B&quot;&gt; &lt;constructor-arg ref=&quot;a&quot;/&gt;&lt;/bean&gt; 如上就是形成了循环依赖。构造函数注入的方法是无法处理的，但Setter注入的方法能够处理此类循环，但还是不建议在配置中使用循环依赖。 2.4 依赖解析过程Spring容器的启动过程大致可分为两个主要阶段。在第一个阶段，容器处理配置元数据并建立元数据中存在的Bean定义，并对这些Bean进行验证。在该步骤中，Bean并没有被创建，相关的属性也没有被注入。在第二个阶段，首先完成Bean的创建，然后完成依赖注入。但实际上，并不是所有的Bean都被创建，在容器启动期间，仅创建了无状态作用域的Bean。 一个Bean在被完全创建且自己的依赖项被注入之前是不会作为一个依赖项被注入到其他Bean中去的。因此，必须确保被注入某一Bean中的Bean依赖项被完全配置且在目标Bean中使用。唯一的例外就是循环依赖，可以通过Setter方法来处理循环依赖，但存在缺陷，最好不要这样。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式详解]]></title>
    <url>%2F2019%2F05%2F06%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1、什么是设计模式？首先我们来看第一个问题什么是设计模式？在百度百科中它的定义是这样的： 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。(百度百科) 其实设计模式是人们实践的产物，在初期的开发过程中好多人发现再进行重复的代码书写，那些开发大牛们就不断总结、抽取最终得到了大家的认可于是就产生了设计模式，其实设计模式的种类可以分为23种左右，今天主要和大家一起学习一下单例设计模式，因为这种设计模式是使用的最多的设计模式。在以后的文章中会给大家带来其他模式的讨论。 2、为什么会有单例设计模式？我们都知道单例模式是在开发中用的最多的一种设计模式，那么究竟为什么会有单例设计模式呢？对于这个问题相信有很多会写单例的人都会有个这个疑问。在这里先说一下单例的用途，然后举一个例子大家就会明白为什么会有单例了。单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。从其名字中我们就可以看出所谓单例，就是单个实例也就是说它可以解决的问题是：可以保证一个类在内存中的对象的唯一性，在一些常用的工具类、线程池、缓存，数据库，账户登录系统、配置文件等程序中可能只允许我们创建一个对象，一方面如果创建多个对象可能引起程序的错误，另一方面创建多个对象也造成资源的浪费。在这种基础之上单例设计模式就产生了因为使用单例能够保证整个应用中有且只有一个实例，看到这大家可能有些疑惑，没关系，我们来举一个例子，相信看完后你就会非常明白，为什么会有单例。 假如有一个有这么一个需求，有一个类A和一个类B它们共享配置文件的信息，在这个配置文件中有很多数据如下图 如上图所示现在类ConfigFile中存在共享的数据Num1，Num2，Num3等。假如在类A中修改ConfigFile中数据，在类A中应该有如下代码:12ConfigFile configFile=new ConfigFile();configFile. Num1=2; 这个时候configFile中的Num1=2，但是请注意这里是new ConfigFile是一个对象，想象一下在进行了上述操作后类B中进行如下操作：12ConfigFile configFile=new ConfigFile();System. out.println(&quot;configFile.Num1=&quot; +configFile.Num1); 即直接new ConfigFile();然后打印Num1,大家思考一下这时候打印出的数据为几？我想你应该知道它打印的结果是这样的：configFile.Num1=1;也就是说因为每次调用都创建了一个ConfigFile对象，所以导致了在类A中的修改并不会真正改变ConfigFile中的值，它所更改的只是在类A中说创建的那个对象的值。假如现在要求在类A中修改数据后，要通知类B，即在类A和类B中操作的数据是同一个数据，类A改变一个数据，类B也会得到这个数据，并在类A修改后的基础上进行操作，那么我们应该怎么做呢?看到这大家可能会说so easy,把ConfigFile中的数据设置为静态不就Ok了吗？对，有这种想法很好，这样做也没有错。但是我们都知道静态数据的生命周期是很长的，假如ConfigFile中有很多数据时，如果将其全部设成静态的，那将是对内存的极大损耗。所以全部设置成静态虽然可行但并不是一个很好的解决方法。那么我们应该怎么做呢？要想解决上面的问题，其实不难，只要能保证对象是唯一的就可以解决上面的问题，那么问题来了如何保证对象的唯一性呢？这样就需要用单例设计模式了。 3、单例模式的设计思想在上面我们说到现在解决问题的关键就是保证在应用中只有一个对象就行了，那么怎么保证只有一个对象呢？ 其实只需要三步就可以保证对象的唯一性 (1)不允许其他程序用new对象。 因为new就是开辟新的空间，在这里更改数据只是更改的所创建的对象的数据，如果可以new的话，每一次new都产生一个对象，这样肯定保证不了对象的唯一性。 (2)在该类中创建对象 因为不允许其他程序new对象，所以这里的对象需要在本类中new出来 (3)对外提供一个可以让其他程序获取该对象的方法 因为对象是在本类中创建的，所以需要提供一个方法让其它的类获取这个对象。 那么这三步怎么用代码实现呢？将上述三步转换成代码描述是这样的： (1)私有化该类的构造函数 (2)通过new在本类中创建一个本类对象 (3)定义一个公有的方法，将在该类中所创建的对象返回 4、单例模式的写法经过3中的分析我们理解了单例所解决的问题以及它的实现思想，接着来看看它的实现代码，单例模式的写法大的方面可以分为5种五种①懒汉式②饿汉式③双重校验锁④静态内部类⑤枚举。接下来我们就一起来看看这几种单例设计模式的代码实现，以及它们的优缺点。 4.1 单例模式的饿汉式[可用]12345678public class Singleton &#123; private static Singleton instance=new Singleton();private Singleton()&#123;&#125;;public static Singleton getInstance()&#123;return instance;&#125;&#125; 访问方式:Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。 优点：从它的实现中我们可以看到，这种方式的实现比较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。 缺点：由于在类加载的时候就实例化了，所以没有达到Lazy Loading(懒加载)的效果，也就是说可能我没有用到这个实例，但是它也会加载，会造成内存的浪费(但是这个浪费可以忽略，所以这种方式也是推荐使用的)。 4.2 单例模式的饿汉式变换写法[可用]1234567891011121314public class Singleton&#123; private static Singleton instance = null; static &#123;instance = new Singleton();&#125; private Singleton() &#123;&#125;; public static Singleton getInstance() &#123;return instance;&#125;&#125; 访问方式： Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。 可以看到上面的代码是按照在2中分析的那三步来实现的，这中写法被称为饿汉式，因为它在类创建的时候就已经实例化了对象。其实4.2和4.1只是写法有点不同，都是在类初始化时创建对象的，它的优缺点和4.1一样，可以归为一种写法。 4.3 单例模式的懒汉式[线程不安全，不可用]1234567891011121314public class Singleton &#123; private static Singleton instance=null; private Singleton() &#123;&#125;; public static Singleton getInstance()&#123; if(instance==null)&#123;instance=new Singleton();&#125;return instance;&#125;&#125; 这种方式是在调用getInstance方法的时候才创建对象的，所以它比较懒因此被称为懒汉式。 在上述两种写法中懒汉式其实是存在线程安全问题的，喜欢刨根问题的同学可能会问，存在怎样的线程安全问题？怎样导致这种问题的？好，我们来说一下什么情况下这种写法会有问题。在运行过程中可能存在这么一种情况：有多个线程去调用getInstance方法来获取Singleton的实例，那么就有可能发生这样一种情况当第一个线程在执行if(instance==null)这个语句时，此时instance是为null的进入语句。在还没有执行instance=new Singleton()时(此时instance是为null的)第二个线程也进入if(instance==null)这个语句，因为之前进入这个语句的线程中还没有执行instance=new Singleton()，所以它会执行instance=new Singleton()来实例化Singleton对象，因为第二个线程也进入了if语句所以它也会实例化Singleton对象。这样就导致了实例化了两个Singleton对象。所以单例模式的懒汉式是存在线程安全问题的，既然它存在问题，那么可能有解决这个问题的方法，那么究竟怎么解决呢？对这种问题可能很多人会想到加锁于是出现了下面这种写法。 4.4 懒汉式线程安全的[线程安全，效率低不推荐使用]1234567891011121314public class Singleton &#123; private static Singleton instance=null; private Singleton() &#123;&#125;; public static synchronized Singleton getInstance()&#123; if(instance==null)&#123;instance=new Singleton();&#125;return instance;&#125;&#125; 缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。 4.5 单例模式懒汉式[线程不安全，不可用]对于上述缺陷的改进可能有的人会想到如下的代码 12345678910111213public class Singleton7 &#123; private static Singleton instance=null; public static Singleton getInstance() &#123;if (instance == null) &#123;synchronized (Singleton.class) &#123;instance = new Singleton();&#125;&#125;return instance;&#125;&#125; 其实这种写法跟4.3一样是线程不安全的，当一个线程还没有实例化Singleton时另一个线程执行到if(instance==null)这个判断语句时就会进入if语句，虽然加了锁，但是等到第一个线程执行完instance=new Singleton()跳出这个锁时，另一个进入if语句的线程同样会实例化另外一个Singleton对象，线程不安全的原理跟4.3类似。因此这种改进方式并不可行，经过大神们一步一步的探索，写出了懒汉式的双重校验锁。 4.6 单例模式懒汉式双重校验锁[推荐用]12345678910111213141516171819public class Singleton &#123;/*** 懒汉式变种，属于懒汉式中最好的写法，保证了：延迟加载和线程安全*/private static Singleton instance=null; private Singleton() &#123;&#125;; public static Singleton getInstance()&#123;if (instance == null) &#123;synchronized (Singleton.class) &#123;if (instance == null) &#123;instance = new Singleton();&#125;&#125;&#125;return instance;&#125;&#125; 访问方式： Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。 Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (instance== null)检查，这样就可以保 证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (instance== null)，直接return实例化对象。 优点：线程安全；延迟加载；效率较高。 4.7 内部类[推荐用]12345678910111213public class Singleton&#123; private Singleton() &#123;&#125;; private static class SingletonHolder&#123;private static Singleton instance=new Singleton();&#125; public static Singleton getInstance()&#123;return SingletonHolder.instance;&#125;&#125; 访问方式： Singleton instance = Singleton.getInstance(); 得到这个实例后就可以访问这个类中的方法了。这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonHolder类，从而完成Singleton的实例化。类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 优点：避免了线程不安全，延迟加载，效率高。 4.8 枚举[极推荐使用]123456789public enum SingletonEnum &#123; instance; private SingletonEnum() &#123;&#125; public void method()&#123;&#125;&#125; 访问方式： SingletonEnum.instance.method(); 可以看到枚举的书写非常简单，访问也很简单在这里SingletonEnum.instance这里的instance即为SingletonEnum类型的引用所以得到它就可以调用枚举中的方法了。 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。可能是因为枚举在JDK1.5中才添加，所以在实际项目开发中，很少见人这么写过，这种方式也是最好的一种方式，如果在开发中JDK满足要求的情况下建议使用这种方式。 5、总结在真正的项目开发中一般采用4.1、4.6、4.7、4.8看你最喜欢哪种写法了，一般情况下这几种模式是没有问题的，为了装逼我一般采用4.6这种写法，我们经常用的Android-Universal-Image-Loader这个开源项目也是采用的4.6这种写法，其实最安全的写法是4.8即枚举，它的实现非常简单而且最安全可谓很完美，但是可能是因为只支持JDK1.5吧又或者是因为枚举大家不熟悉所以目前使用的人并不多，但是大家可以尝试下。另外当我们使用反射机制时可能不能保证实例的唯一性，但是枚举始终可以保证唯一性，具体请参考次博客：http://blog.csdn.net/java2000_net/article/details/3983958但是一般情况下很少遇到这种情况。 6、单例模式的在面试中的问题单例模式在面试中会常常的被遇到，因为它是考查一个程序员的基础的扎实程度的，如果说你跟面试官说你做过项目，面试官让你写几个单例设计模式，你写不出来，你觉着面试官会相信吗？在面试时一定要认真准备每一次面试，靠忽悠即使你被录取了，你也很有可能会对这个公司不满意，好了我们言归正传，其实单例设计模式在面试中很少有人会问饿汉式写法，一般都会问单例设计模式的懒汉式的线程安全问题，所以大家一定要充分理解单例模式的线程安全的问题，就这几种模式花点时间，认真学透，面试中遇到任何关于单例模式的问题你都不会害怕是吧。 7、 说明上述文章均引用自：https://blog.csdn.net/q_all_is_well/article/details/82377917 ，感觉写的很不错，就拿来用了。]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lock的使用]]></title>
    <url>%2F2019%2F05%2F05%2FLock%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在Java多线程中，可以使用synchronized关键字来实现线程之间的同步互斥，但在JDK1.5后新增了ReetrantLock类也能达到同样的效果，并且在扩展功能上也更加强大。 1.ReentrantLock类的使用1.1 简单使用 ReentrantLock1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.locks.ReentrantLock;/** * Created by haicheng.lhc on 17/05/2017. * * @author haicheng.lhc * @date 2017/05/17 */public class ReentrantLockTest extends Thread &#123; public static ReentrantLock lock = new ReentrantLock(); public static int i = 0; public ReentrantLockTest(String name) &#123; super.setName(name); &#125; @Override public void run() &#123; for (int j = 0; j &lt; 10000000; j++) &#123; lock.lock(); try &#123; System.out.println(this.getName() + &quot; &quot; + i); i++; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; /** * @param args * @throws InterruptedException */ public static void main(String[] args) throws InterruptedException &#123; ReentrantLockTest test1 = new ReentrantLockTest(&quot;thread1&quot;); ReentrantLockTest test2 = new ReentrantLockTest(&quot;thread2&quot;); test1.start(); test2.start(); test1.join(); test2.join(); System.out.println(i); &#125; 最后的结果是 20000000；如果去掉锁，那么输出结果是一个小于20000000的不确定的数。 1.2 使用Conditon实现等待/通知12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.jalja.org.base.Thread;import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * Condition 配合Lock 实现线程的等待 与通知 */public class ConditionTest&#123; public static ReentrantLock lock=new ReentrantLock(); public static Condition condition =lock.newCondition(); public static void main(String[] args) &#123; new Thread()&#123; @Override public void run() &#123; lock.lock();//请求锁 try&#123; System.out.println(Thread.currentThread().getName()+&quot;==》进入等待&quot;); condition.await();//设置当前线程进入等待 &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock();//释放锁 &#125; System.out.println(Thread.currentThread().getName()+&quot;==》继续执行&quot;); &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; lock.lock();//请求锁 try&#123; System.out.println(Thread.currentThread().getName()+&quot;=》进入&quot;); Thread.sleep(2000);//休息2秒 condition.signal();//随机唤醒等待队列中的一个线程 System.out.println(Thread.currentThread().getName()+&quot;休息结束&quot;); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock();//释放锁 &#125; &#125; &#125;.start(); &#125;&#125; 需要注意，在调用condition.await()和condition.signal()之前必须先调用lock.lock()代码，获得同步监视器，也就是先要获得锁。 1.3 使用多个Condition实现通知部分线程新建MyService.java：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package service; importjava.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;importjava.util.concurrent.locks.ReentrantLock; public class MyService &#123; privateLock lock = new ReentrantLock(); publicCondition conditionA = lock.newCondition(); publicCondition conditionB = lock.newCondition(); publicvoid awaitA() &#123; try&#123; lock.lock(); System.out.println(&quot;beginawaitA时间为&quot; +System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionA.await(); System.out.println(&quot; end awaitA时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; publicvoid awaitB() &#123; try&#123; lock.lock(); System.out.println(&quot;beginawaitB时间为&quot; +System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionB.await(); System.out.println(&quot; end awaitB时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; publicvoid signalAll_A() &#123; try&#123; lock.lock(); System.out.println(&quot; signalAll_A时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionA.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125; publicvoid signalAll_B() &#123; try&#123; lock.lock(); System.out.println(&quot; signalAll_B时间为&quot; + System.currentTimeMillis() +&quot; ThreadName=&quot; + Thread.currentThread().getName()); conditionB.signalAll(); &#125;finally &#123; lock.unlock(); &#125; &#125; 新建ThreadA.java :1234567891011121314151617181920212223242526272829303132333435package extthread; import service.MyService; public class ThreadA extends Thread &#123; privateMyService service; publicThreadA(MyService service) &#123; super(); this.service= service; &#125; @Override publicvoid run() &#123; service.awaitA(); &#125;&#125; 新建ThreadB.java :1234567891011121314151617181920212223242526272829303132333435package extthread; import service.MyService; public class ThreadB extends Thread &#123; privateMyService service; publicThreadB(MyService service) &#123; super(); this.service= service; &#125; @Override publicvoid run() &#123; service.awaitB(); &#125;&#125; 新建Run.java :12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package test; import service.MyService;import extthread.ThreadA;import extthread.ThreadB; public class Run &#123; publicstatic void main(String[] args) throws InterruptedException &#123; MyServiceservice = new MyService(); ThreadAa = new ThreadA(service); a.setName(&quot;A&quot;); a.start(); ThreadBb = new ThreadB(service); b.setName(&quot;B&quot;); b.start(); Thread.sleep(3000); service.signalAll_A(); &#125;&#125; 运行结果，只有线程A被唤醒了。 1.4 公平锁和非公平锁锁Lock分为公平锁和非公平锁。公平锁表示线程获取锁的顺便是按照线程加锁的顺序来分配的，即先来先得，先进先出的顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的。公平锁的顺序是大体如此，并不是100%。在默认情况下，ReentrantLock类使用的是非公平锁。 1.5 使用Conditon可实现顺序执行2.ReentrantReadWriteLock类的使用ReentrantReadWriteLock类表示有两种锁，一个是读操作相关的锁，也称共享锁；另一个是写操作相关的锁，也叫排他锁。写锁与写锁互斥，写锁与读锁互斥，读锁与读锁不互斥。 读锁是长这样的：123456.....private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();.....lock.readLock().lock().....lock.readLock().unlock() 写锁长这样：123456.....private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();.....lock.writeLock().lock().....lock.writeLock().unlock() 使用方法和普通的Lock类似，只要记得写锁与写锁互斥，写锁与读锁互斥，读锁与读锁不互斥。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程间通信]]></title>
    <url>%2F2019%2F05%2F05%2F%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[1.使用wait/notify实现线程间的通信1.1 等待/通知机制的实现方法wait()的作用是使当前执行代码的线程进行等待。在调用wait()之前，线程必须获得该对象的对象级别锁，即只能在同步方法或同步代码块中调用wait()方法。在执行wait()方法后，当前线程释放锁。在从wait()返回前，线程与其他线程竞争重新获得锁。方法notify()也要在同步方法或同步代码块中调用。该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则按优先级来获取，否则随机挑选一个呈wait状态的线程，对其发出通知notify，并使它进入就绪队列，也叫锁池。另外需要说明的是，在执行notify()方法之后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程将程序执行完，也就是推出synchronized代码块后，当前线程才会释放锁，然后由就绪队列里的线程争夺锁。当一个获得了该对象的wait()线程运行完毕后，会释放该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。 1.2 方法wait(long)的使用带一个参数的的wait(long)方法的功能是等待某一时间内是否有线程对锁唤醒，如果超过这个时间则自动唤醒。 1.3 等待wait的条件发生变化如果采用if判断，当线程从wait中唤醒时，那么将直接执行处理其他业务逻辑的代码，但这时候可能出现另外一种可能，条件谓词已经不满足处理业务逻辑的条件了，从而出现错误的结果，于是有必要进行再一次判断，所有一般wait()方法是在while循环里，这样便于检测wait的条件是否变化。 2.生产者/消费者模式的实现2.1 线程假死现象“假死”现象其实就是线程全部进入WAITING等待状态，这时，程序不再执行任何业务功能，整个项目呈停止状态。“假死”出现的原因是notify唤醒的时候，也许是异类，也许是同类，比如生产者唤醒生产者，或消费者唤醒消费者这样的情况。如果按这样运行的比率积少成多，最终就会导致所有的线程都不能继续运行下去，大家都在等待，都呈WAITING状态，就是”假死”。 3.方法join的使用方法join()的作用是使所属的线程对象X正常执行run()方法中的任务，而使当前线程Z进行无限期的阻塞，等待线程X销毁后再继续执行线程Z后面的代码。 3.1 join与synchronized的区别方法join具有使线程排队运行的作用，有些类似同步的运行效果。join与synchronized的区别是：join在内部使用wait()方法进行等待，而sychroized该关键字使用的是”对象监视器”原理做为同步。 3.2 方法join(long)与sleep(long)的区别join(long)的功能在内部是使用wait(long)方法实现的，所以join(long)方法具有释放锁的特点。而Thread.sleep(long)方法却不释放锁。 4.ThreadLocal的使用ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 4.1 ThreadLocal的内部结构图 从上面的结构图，我们已经窥见ThreadLocal的核心机制： 每个Thread线程内部都有一个Map。Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 4.2 ThreadLocal与InheritableThreadLocal的区别ThreadLocal和InheritableThreadLocal本质上只是为了方便编码给的工具类，具体存数据是ThreadLocalMap 对象。ThreadLocalMap 存的key对象是ThreadLocal，value就是真正需要存的业务对象。Thread里通过两个变量持用ThreadLocalMap 对象，分别为：threadLocals和inheritableThreadLocals。InheritableThreadLocal之所以能够完成线程间变量的传递，是在new Thread()的时候对inheritableThreadLocals对像里的值进行了复制。子线程通过继承得到的InheritableThreadLocal里的值与父线程里的InheritableThreadLocal的值具有相同的引用，如果父子线程想实现不影响各自的对象，可以重写InheritableThreadLocal的childValue方法。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>线程间通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2F2019%2F05%2F03%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[关键字volatile的主要作用是使变量在多个线程间可见。具体来说就是，volatile关键字，可以强制的从公共内存中读取变量的值，这样就不会因为私有堆栈中的值和公共堆栈中的值不同步而导致错误。 1.volatile 和 synchronized 的比较1) volatile只能修饰于变量，而 synchronized可以修饰方法，以及代码块。2) 多线程访问 volatile不会发生阻塞，而 synchronized会出现阻塞。3) volatile能保证数据的可见性，但不能保证原子性。 synchronized两者都可以保证。4) volatile解决的是变量在多个线程之间的可见性，而 synchronized解决的是多个线程之间访问资源的同步性。 2. i++操作时的非线程安全问题表达式i++的操作步骤分解如下： 1)从内存中取出i的值2)计算i的值3)将i的值写到内存中 假如在第二步计算值的时候，另外一个线程也修改i的值，这时候就会出现脏数据。解决方法就是使用 synchronized关键字。 3.synchronized有和volatile一样的功能synchronized不仅可以保证同步，还可以保证可见性。在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>volatile关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized同步语句块]]></title>
    <url>%2F2019%2F05%2F02%2Fsynchronized%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97%2F</url>
    <content type="text"><![CDATA[用关键字 synchronized 来声明方法在某些情况下是有弊端的，比如A线程调用了同步方法执行一个长时间的任务，那么B线程则必须等待比较长的时间。在这种情况下可以使用 synchronized同步语句块 来解决。 synchronized方法 是对当前对象加锁，而 synchronized同步语句块 是对某一个对象加锁。 1.用同步代码块解决同步方法的弊端同步方法的弊端上面说过了，就是效率慢。为什么同步代码块就能解决？因为当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问该object对象中的非 synchronized(this) 同步代码块。 2.synchronized代码块间的同步性当一个线程访问object的 synchronized(this)同步代码块时，其他线程对同一个object中所有其他 synchronized(this)同步代码块的访问将被阻塞，这说明 synchronized 使用的对象监视器是一个。但可以异步访问 synchronized(其他对象) 的语句块。因为这时候他们的对象监视器就不是同一个了。 3.synchronized锁定的是当前对象synchronized(this)代码块锁定的是当前对象，和 synchronized方法是一样的。这就意味着，他们的对象监视器是同一个，会发生排斥。也就是说，当A线程在访问object的 synchronized(this)同步代码块的时候，那么B线程这时候访问object中的 synchronized方法就会受阻，必须等A线程访问结束，释放了锁后,B线程才能访问。因为他们持有的是同一个锁，都是锁定的当前对象。同一个object里的 synchronized(anthing) 和 synchronized(this) 是不互斥的，可以异步执行。同一个object里的 synchronized(anthing) 和 synchronized方法 是不互斥的，可以异步执行。同一个object里的 synchronized方法 和 synchronized(this) 是互斥的，必须同步执行。 4.synchronized(非this对象x)的三个结论“synchronized(非this对象x)”格式的写法是将x对象本身作为”对象监视器” 1)当多个线程同时执行 synchronized(x){}同步代码块时呈同步效果。2)当其他线程执行x对象中 synchronized同步方法时呈同步效果。3)当其他线程执行x对象方法里面的 synchronized(this)代码块时也呈同步效果。注意：如果其他线程调用的是不加 synchronized 关键字的方法时，还是异步调用 5.静态同步 synchronized方法与 synchronized(class)代码块synchronized关键字还可以用在 static静态方法上，这样写的话，就是对当前.java文件对应的Class类持锁。和 synchronized关键字加到非static静态方法不一样，这个是给对象上锁。 1)当A线程执行object里的 synchronized修饰的 static静态方法时，那么其他线程不能同时执行该object里用 synchronized修饰的static静态方法。属于互斥状态。1)当A线程执行object里的 synchronized修饰的 static静态方法时，其他线程可以执行该object里用 synchronized修饰的非static静态方法。不属于互斥状态，因为不是同一把锁。3)同步synchronized(xx.class)作用和 synchronized static 方法的作用一样。 synchronized static 方法需是xx.class里的。 6.数据类型String的常量池特性在jvm中具有String常量池缓存的功能。简单来说，就是我输一次A，如果String常量池没有A，那么这个A就会被保存在String常量池里。当我要用A时，这时就会把String常量池里的A指向变量。所有的A都是同一个。如果把A当作锁，那么便会出现相同的锁，就会出现问题。 7.锁对象的改变如果锁对象的值中途改变，那么锁也就会改变，马上会由同步变为异步。需要注意的是：只要对象不变，即使对象的属性被改变，运行的结果还是同步。比如对象是USER这个类，运行过程中，改变了USER里的一个属性name的值，但对象还是没变，还是会同步执行下去。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized同步方法]]></title>
    <url>%2F2019%2F04%2F29%2Fsynchronized%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[”非线程安全“会在多个线程对同一个对象中的实例对象进行并发访问时发生，产生的后果就是”脏读“，也就是取到的数据其实是被更改过的。而”线程安全“就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。 #1.方法内的变量为线程安全 方法中的变量不存在非线程安全问题，这是方法内部的变量是私有的特性造成的。 #2.实例变量非线程安全 如果多个线程共同访问1个对象中的实例变量，需要在方法前添加关键字 synchronized 。这样就不会出现非线程安全问题。 #3.多个对象多个锁 123456Hbbq h1 = new Hbbq();Hbbq h2 = new Hbbq();Thread athread = new Thread(h1);athread.start();Thread bthread = new Thread(h2);bthread.start(); 从以上代码可以看出，我们创建了两个 Hbbq 的实例对象。这样的话，加了 synchronized 的方法，便会产生两个锁，结果就不会是同步，而是以异步的方式运行的。如果多个线程访问多个对象，JVM就会创建多个锁，就像上面的示例一样。同步的单词是 synchronized ，异步的单词是 asynchronized。 #4.synchronized方法与锁对象 当两个线程同时访问一个对象的不同的两个方法：第一次实验的是一个同步的方法，一个不同步的方法第二次实验的是两个都是同步的方法 代码我就不贴了，直接写结论：1）A线程先持有object对象的lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。2）A线程先持有object对象的lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需等待，也就是同步。 #5.脏读 出现脏读的原因就是不同步。解决的方法就是加上同步synchronized关键字。这里注意一点，当一个线程A调用了对象里加入synchronized关键字的X方法时，那么A线程就获得了X的方法锁，更准确的讲，是获得了这个对象的锁，其他线程必须等待A线程执行完毕才可以调用X方法，但其他线程可以随意调用其他的非synchronized同步方法。所以，需要把set 和 get 方法都加上 synchronized 关键字，这样的话就可以避免出现脏读。 #6.synchronized锁重入 可重入锁的概念是：自己可以再次获取自己的内部锁。这样就可以调用 synchronized方法 里的 synchronized方法。可重入锁也支持在父子类继承的环境中。在子类中调用父类里的变量，值也可以同步。 #7.出现异常，锁自动释放 就是说，当一个线程执行的代码出现异常时，那么这个线程所持有的锁会被自动释放，然后别的线程就可以继续去调用这个方法了。 #8.同步不具有继承性 当一个子类继承一个父类时，子类重写父类的 synchronized 方法，却没有加关键字 synchronized，这样就会造成非线程安全(异步)。由此可以看出，同步不能继承。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>synchronized关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[有三种方式来停止线程：1. 正常执行 run()方法，run()方法结束后，线程终止。2. 使用 stop 方法强行终止线程，不推荐使用，会造成不可预料的后果。3. 使用 interrupt 方法中断线程。 现在对于第三种方式来详细了解一下。在Java的SDK中，Thread.java类提供了两种方法：1) this.interrupted()：测试当前线程是否已经中断。2) this.isinterrupted()：测试线程是否已经中断。interrupted()是静态方法，所以我们用Thread.interrupted()方法表示，它调用的是currentThread().isInterrupted(true)方法，即说明是返回当前线程的是否已经中断的状态值，而且有清理中断状态的机制。而isInterrupted()是一个实例方法，所以我们用this.isInterrupted()方法表示，它调用的是isInterrupted(false)方法，意思是返回线程是否已经中断的状态值，与Thread.interrupted()方法相反，它没有清理中断状态的机制。 二者的区别在于：interrupted()是static方法，调用的时候要用Thread.interrupted()，而isInterrupted()是实例方法，调用时要用线程的实例调用；Thread.interrupted()：测试当前线程是否已经是中断状态，执行后具有将状态标志清除为false的功能；this.isInterrupted()：测试线程Thread对象是否已经是中断状态，但不清除状态标志。 线程的停止——抛异常法1234567891011121314151617181920public class MyThread4 extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 50000; i++) &#123; if (this.isInterrupted()) &#123; System.out.println( &quot;线程已经结束，我要退出&quot; );// return; //这是return法停止线程 throw new InterruptedException(); //抛异常法停止线程 &#125; System.out.println( &quot;i=&quot; + (i + 1) ); &#125; System.out.println( &quot;我是for下面的语句，我被执行说明线程没有真正结束&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;进入MyThread.java类中run方法的catch异常了&quot; ); e.printStackTrace(); &#125; &#125;&#125; 1234567891011public static void main(String[] args) &#123; try &#123; MyThread4 myThread4 = new MyThread4(); myThread4.start(); Thread.sleep( 20); myThread4.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 推荐使用抛异常法。 线程的停止——在沉睡中停止这个名字非常好听，让我们看下具体是怎么实现的。12345678910111213141516171819202122public void run() &#123; super.run(); try &#123; System.out.println( &quot;begin run&quot; ); Thread.sleep( 500 ); System.out.println( &quot;begin end&quot; ); &#125; catch (InterruptedException e) &#123; System.out.println(&quot;在沉睡中终止&quot;); e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyThread5 thread5 = new MyThread5(); thread5.start(); Thread.sleep( 20 ); thread5.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println( &quot;main catch&quot; ); e.printStackTrace(); &#125; &#125; 其实就是在执行中断操作前，执行一个sleep()方法。那为什么这样就能停止线程呢？看这句话：当线程处于下面的状况时（（1）如果线程在调用 Object 类的 wait()、wait(long) 或 wait(long, int) 方法，或者该类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个InterruptedException异常。这个时候，我们可以通过捕获InterruptedException异常来终止线程的执行，具体可以通过return等退出或改变共享变量的值使其退出。）这样看来，其实这两个方法都属于抛异常法，一个是主动抛出异常，一个是调用sleep()后，被系统抛出异常。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识多线程]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%88%9D%E8%AF%86%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[开始系统地来学习多线程。采用边学变记录的方式。不想耽误太多时间来码字，所以我打算写的随意一点，以自己能看懂为目的，来记录一些需要记住的知识，便于日后的复习，虽然也可能根本不复习，但是记录还是有用的，至少能让后我现在加深一次记忆。 1. 进程，线程1.1 进程运行在内存中的exe程序，就是进程。就像任务管理器里看到的exe程序，都是正在运行的进程。 1.2 线程线程可以理解为，在进程中独立运行的子任务。打个比方，QQ.exe运行时就有很多子任务在同时运行，比如好友视频线程，下载文件线程，发送表情线程等等。这些不同的任务都能同时进行，这些子任务都可以理解为线程在工作。 1.3 线程的优点使用多线程，可以在同一时间同时运行不同种类的任务。通过一个图可以清楚的看到优点所在。使用多线程，任务2便不用等到任务1运行完才能运行。这是就是多线程的优点，使用多线程也就是在使用异步。 2. 使用多线程有两种方法来实现多线程，一种是继承Thread类，一种是实现Runnable接口。因为Java不支持多继承，一个子类只能有一个父类。所以当想创建的线程类已经有一个父类时，就不能再继承Thread类了，这时需要通过实现Runnable类来实现多线程。注意：启动多线程，必须使用thread.start()方法，且类里的方法名必须为run()，开启start()方法后，run()方法会被自动调用。另外还需要知道，执行start()方法的顺序不代表线程启动的顺序，顺序是随机的。 2.1 非线程安全问题指的是多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。解决方法是在方法前加 synchronized 关键字。]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识IO]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%A4%E8%AF%86IO%2F</url>
    <content type="text"><![CDATA[大多数应用程序都需要实现与设备之间的数据传输。在Java中，将通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象描述为”流”。Java中的流都位于 java.io 包中，称为IO(输入输出)流。 1.字节流1.1 字节流的概念在计算机中，无论是文本、图片、音频还是视频，所有的文件都是以二进制(字节)形式存在的。IO流中针对字节的输入输出提供了一系列的流，统称为字节流。在JDK中，提供了两个抽象类 InputStream 和 OutputStream ,他们是字节流的顶级父类，所有的字节输入流都继承自 InputStream ，所有的字节输出流都继承自 OutputStream 。 1.2 字节流读写文件针对文件的独写，JDK专门提供了两个类，分别是 FileInputStream 和 FileOutputStream 。FileInputStream 是 InputStream 的子类，它是操作文件的字节输入流，专门用于读取文件中的数据。FileOutputStream 是 OutputStream 的子类，它是操作文件的字节输出流，专门用于把数据写入文件。 1.3 字节流的缓冲区主要代码：12345byte[] buff = new byte[1024];int len;while((len=in.read(buff))!=-1)&#123;out.write(buff,0,len)&#125; 上述代码实现了用缓冲区来拷贝文件。首先定义了一个字节数组，作为缓冲区。字节数组被填满后，执行写入，把字节数组里的内容全部写入。最后输出流关闭时，也会执行写入，可以防止数组里没有写满的没有写入文件。 1.4 字节缓冲流在IO包中提供两个带缓冲的字节流，分别是 BufferedInputStream 和 BufferedOutputStream 。简单理解就是，自带了缓冲区的字节流。使用方法，把类包装起来。主要代码如下：BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;src.txt&quot;));就这样包起来，所以也叫包装流。 2.字符流InputStream 类和 OutputStream 类在读写文件时操作的都是字节。同样，JDK也提供了字符流，用来操作字符。Reader 和 Writer 分别是两个抽象的顶级父类。Reader是字符输入流，用与读取字符。Writer是字符输出流，用于写入字符。 2.1 字符流操作文件FileReader 是 Reader 的子类，可以读取一个或一组字符。FileWriter 是 Writer 的子类，用于写入字符。同字节缓冲流一样，字符也有字符缓冲流 BufferedReader 和 BufferedWriter 。操作方法也一样。需要注意的是，BufferedWriter 中的一个重要方法 readLine()，和 FileOutputStream 里的 read()，用法一样，区别是read()一次读取一个字节，而readLine()一次读取一行字符。需要注意。 2.2 转换流字节流和字符流之间可以互相转换。利用 InputStreamReader 和 OutputStreamWriter 这两个类进行转换。转换流其实也是一种包装流，其中 OutputStreamWriter 是 Writer 的子类,InputStreamReader 是 Reader 的子类。用的时候包装一下就可以了，和上面两个缓冲流用法一样。 3.其他流3.1 ObjectInputStream 和 ObjectOutputStream程序运行时，会创建对象，程序结束后，这些对象会被垃圾回收。如果希望永久保存这些对象，则可以将对象转为字节数据写入硬盘，这个过程叫对象序列化。JDK提供了 ObjectOutputStream 来实现序列化, ObjectInputStream 用来反序列化。当对象序列化时，必须保证对象实现了Serializable接口，否则程序会报错。]]></content>
      <categories>
        <category>Java</category>
        <category>IO</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件装载流程]]></title>
    <url>%2F2019%2F04%2F15%2Fclass%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1.装载流程图class文件的装载流程如图所示。 2.类装载的条件首先我们要搞清楚，class只有在必须要使用时才会被装载。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：· 当创建一个类的实例时，比如使用new关键字，或者通过反射，克隆，反序列化· 当调用类的静态方法，即当使用了字节码 invokestatic 指令· 当使用类或接口的静态字段时（final常量除外），比如，使用 getstatic 或者 putstatic 指令· 当使用 java.lang.refect 包中的方法反射类的方法时· 当初始化子类时，要求先初始化父类· 作为启动虚拟机，含有main()方法的那个类 3.流程分析3.1 加载类加载类处于类装载的第一个阶段。在加载类时，java虚拟机必须完成以下工作:· 通过类的全名，获取类的二进制数据流· 解析类的二进制数据流为方法区内的数据结构· 创建java.lang.Class 类的实例，表示该类型 对于类的二进制流数据，虚拟机可以通过多种途径产生和获得。最一般地是通过文件系统读入一个class文件。在获取类的二进制信息后，Java虚拟机就会处理这些数据，并最终转化为一个java.lang.Class的实例，java.lang.Class实例是访问类型元数据的接口，也是实现反射的关键数据。通过class类提供的接口，可以访问一个类的方法，字段等信息。 3.2 连接连接可以分为三个步骤：验证，准备，解析。 3.2.1 验证类当类加载到系统后，就开始连接操作，验证是连接操作的第一步。大体上Java虚拟机需要做以下的检查：检查的内容如图所示，比较详细，我就不一一说明了。 3.2.2 准备当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置初始值。如果类中存在常量字段，那么常量字段也会在准备阶段被附上正确的值，这个赋值属于Java虚拟机的行为，属于变量的初始化。在这个阶段，不会有任何Java代码被执行。 3.2.3 解析类在准备阶段完成后，就进入到了解析阶段。解析阶段的工作就是将类、接口、字段和方法的符号引用转为直接引用。Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。这就是解析阶段的工作，将类、接口、字段和方法的符号引用转为直接引用。 3.3 初始化类的初始化是类装载的最后一个阶段。此时，类才会开始执行Java字节码。主要工作是执行类的初始化方法 。方法是由编译器自动生成的，它是由类静态成员的赋值语句以及 static 语句结合产生的。]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>class文件装载流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笑忘录]]></title>
    <url>%2F2019%2F04%2F14%2F%E7%AC%91%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[人与政权的斗争，就是记忆与遗忘的斗争。 —米兰昆德拉 今天下午看到了一些东西。这些东西颠覆了我的认知。让我感到无奈，无力，压抑。 我很难受，但是却没法和人说。我深知互联网不是可以畅所欲言的地方。 在这一点上，他们是成功的。身边也无人可说，因为很多人都不知道，至少我身边的人应该是不知道。在这一点上，他们也是成功的。 但这样是不对的，不应该以这样的方式来对待。我们不应该忘记，我们也不能忘记，我们需要一个说法。 我避免了很多的敏感词汇，这样的叙述让我很难受，丝毫表达不出我所想。但我又很怂，我不知道写在这里有没有事。在一点上，我更加敬佩那些能够勇于发声的人。这样的人，最终都不会有什么好的结果。但这样的人，才是真正伟大的人。 写出来这些话，我认为这样能让我舒服一点，但是好像没什么用。了解了更多，只会觉得我们更加可悲。似乎理解了一些人，也感觉自己之前的思想很可笑，无知。 我希望她能够等到那一天的到来，如果不行，我希望我可以等到那一天的到来。如果还不行，至少希望自己到时不要已经变成一个麻木不堪，对什么都不在意的人。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>文字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo插入图片]]></title>
    <url>%2F2019%2F04%2F14%2Fpictest%2F</url>
    <content type="text"><![CDATA[1.更改 _config.yml 配置文件首先确认_config.yml 中有 post_asset_folder:true。Hexo 提供了一种更方便管理 Asset 的设定：post_asset_folder当您设置post_asset_folder为true参数后，在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2.安装插件到博客的根目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save命令来进行插件的安装，用于加载本地文件。 3.创建文章执行 hexo new page pictest 创建文章。执行后我们会发现，这次创建 pictest.md 文章的同时，还会多出来一个 pictest 的文件夹。我们可以把文章里所用到的静态资源都放在这里，然后在文章里进行引用。 4.引用方式![图片别名随便写](pictest/图片名称.jpg) 5.引用我们来引用一张图片试一下 6.部署三连hexo cleanhexo ghexo d 7.打开浏览器查看是否成功]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法初试]]></title>
    <url>%2F2019%2F04%2F12%2FMarkdown%E8%AF%AD%E6%B3%95%E5%88%9D%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.标题测试1.1不错 1.2还可以吧 1.3应该行 2.链接测试2.1 普通链接这是我的微博这是我的简书代码：[这是我的微博](https://weibo.com/u/6059487421?is_hot=1/)[这是我的简书](https://www.jianshu.com/u/21a1a8bdb771/) 2.2 自动链接这是我的微博：https://weibo.com/u/6059487421?is_hot=1这是我的简书：https://www.jianshu.com/u/21a1a8bdb771 3.代码测试3.1 行内代码system.out.println(&quot;你好！&quot;) 3.2 多行代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546package cn.hfbin.sync003;/** * 对象锁的同步和异步问题 * @author cn.hfbin * */public class MyObject &#123; public synchronized void method1()&#123; try &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** synchronized */ public void method2()&#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; final MyObject mo = new MyObject(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method1(); &#125; &#125;,&quot;t1&quot;); Thread t2 = new Thread(new Runnable() &#123; @Override public void run() &#123; mo.method2(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125;&#125; 4.引用测试 我已经说过：我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。表示尽管自己惯于冷眼看待军阀政府的文过饰非，从最坏最恶毒的方面去推测他们可能的做法，仍然料不到他们竟然凶残到超出自己的想象。 ​]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号大记]]></title>
    <url>%2F2019%2F04%2F10%2FsecondBlog%2F</url>
    <content type="text"><![CDATA[待会有课夜里也有课今天跑不成步了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10号小记]]></title>
    <url>%2F2019%2F04%2F10%2Fnewpapername%2F</url>
    <content type="text"><![CDATA[今天有点冷，还可以吧。运动会，可以买水了。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>日记</tag>
      </tags>
  </entry>
</search>
